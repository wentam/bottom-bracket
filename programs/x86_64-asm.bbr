;; NOTE: neovim treesitter 'commonlisp' plugin works-ish for indentation, :set filetype=commonlisp
;; NOTE: :set shiftwidth=1
;; NOTE: neovim :set foldmethod=indent gives you kinda-working code folding
;; NOTE: if you accidentally set the filetype to 'lisp' and not 'commonlisp', the editor will be
;; unusably slow until you restart neovim. The builtin lisp indentor is very slow.

;; NOTE: This file is "double wide" as per STYLE.md. You can use 200 columns.

;; NOTE: we intentionally don't support disp32 absolute addressing like qword[my-label]
;; because our data often exists outside of 32-bit addressable space. Using disp32 would be unsafe.
;;
;; Use mov rdi, foo; mov rsi, qword[rdi] instead.

; TODO build out these comments to describe generally how to encode x86_64 instructions from
; a table.

; REX: 0100WRXB
; * W: 1 = 64-bit operands, 0 = 32 bit operands
; * R: 1 = extend register access r8-r15
; * X: 1 = SIB byte index field can use r8-r15
; * B: 1 = R/M can use r8-r15 - AND - SIB base field can use r8-r15

; MODRM: mod + reg + r/m
; * mod = addressing mode
;   * 00 = mem
;   * 01 = mem+disp8
;   * 10 = mem+disp32
;   * 11 = register direct
;   * When mod = 00 and r/m = 101, it's absolute 32-bit address or RIP-relative addressing [which?]
;   * When r/m = 100, it's always SIB unless mod=11
; * reg [3 bits]:
;   * 000 rax/eax
;   * 001 rcx/ecx
;   * 010 rdx/edx
;   * 011 rbx/ebx
;   * 100 rsp/esp
;   * 101 rbp/ebp
;   * 110 rsi/esi
;   * 111 rdi/edi
; * reg [3 bits] when R is 1:
;   * 000 r8
;   * 001 r9
;   * 010 r10
;   * 011 r11
;   * 100 r12
;   * 101 r13
;   * 110 r14
;   * 111 r15
;
; * r/m [3 bits] when mod = 11 encodes another register. Refers to r8+ if REX.B = 1
;
; TODO doc SIB byte

;; TODO special case: spl, bpl, sil, and dil require REX byte, we need to make sure those are
;;      encoded correctly
;;        * This is a proper nightmare because instructions like mov al, spl are now invalid b/c
;;          the REX byte promotes us to 64-bit, we need REX for spl, but no REX for al.
;;        * think about what happens with movzx/movsx and different operand sizes.
;;        * probably do this directly in the x86_64-asm macro, don't resolve it in the DSL:
;;          * prepend REX byte if not there in the DSL form and one of these registers is used
;;          * possibly error in some invalid situations that wouldn't work out right
;;          * probably error if one register operand is 32 or 16 bit when these registers are used.
;;        * make sure stuff like mov al, spl produces an error
;;        * one way to handle this might be to treat these registers as their own 'type'
;;          in the instruction table. instead of [r8 r8] you need an entry for [rs8 rs8] -
;;          'really special 8'. As usual, this means more instruction table enumeration.

;; TODO special case: to encode a qword[rsp] operand, we *must* use an SIB byte with base=rsp
;;      even if we're not using scale etc. This is because an r/m value of 100 - rsp's register
;;      number - means SIB.

;; TODO special case: an index of rsp/esp/etc in an SIB byte is invalid, because this register's
;;      number denotes a zero index.
;;        * Make sure we error if the user tries to do this

;; TODO special case: to encode a qword[rbp] operand, we cannot use mod 00/mem. You must use a
;;      displacement encoding and just encode a displacement of zero. This is because rbp's
;;      register number instead denotes RIP-relative addressing.

;; TODO to resolve the above special cases, why not make the first argument of MODRM
;;      include mem-sib and mem-rip-rel. That way, if the user just specified "mem" it could
;;      actually expand into multiple bytes to resolve the problem cases as though they didn't
;;      exist. Unless mem-sib or mem-rip-rel is specified, you know for sure your input number
;;      represents a register intentionally.
;;
;;      ...In fact, in the case of SIB MODRM macro could accept extra parameters to encode the
;;      SIB value, and in the case of disp8/disp32, accept an extra parameter for that value.
;;      This would make "MODRM" a bit of a higher-level abstraction for "memory/register operand"
;;
;;      Building on this, it may make more sense to put the register number field first, as it's
;;      unchanging, then put all of the memory-related operands into a list. That way, in the
;;      mini-DSL a macro could expand into the memory related components in one go [covering
;;      mod, sib, disp8, disp32, rip-rel, everything].
;;
;;      Maybe rename MODRM though if doing this though as the macro name implies that it's
;;      just expanding into the MODRM byte.
;;
;;      Maybe just call the macro "RM" for regmem.
;;
;;      ...Actually, we can even take this one step further and just accept a register number/name
;;      and then our final memory operand interface like [qword rsp*2+2] or something like that.
;;
;;      Actually not quite. 'qword' is defined by the instruction form and has to be resolved
;;      through the instruction table. So maybe just [RM rdi [mem rsp*2+2]] for memory and
;;      [RM rdi rsp] for both registers. Could also optionally accept [RM rdi [qword rsp*2+2]] etc
;;      just to make DSL implementation simpler, and treat it the same as 'mem'.
;;
;;      Normally, I would avoid putting this much into one abstraction, but the special cases
;;      in x86-64 have made all of these components inter-related rather than have proper
;;      separation of concerns. Therefore, the best solution is for us to not separate our
;;      concerns.
;;
;; Memory operands things to check:
;;      [qword 5] for RIP-rel/disp32
;;      Different orders possible: [qword rdi + 5 + rsi * 2]
;;      scale can only be 1 2 4 8
;;      Should error: rdi + rax * 2 + rcx * 4

;; TODO support legacy ah, bh, ch, dh registers?

;; TODO find some kind of assembler encoding test suite
;;   * maybe pull from an existing project: nasm, intel XED, gas, fasm, LLVM MC layer
;;   * maybe port one over to bb-land at some point if licensing allows

;; TODO fancy memory operand like [m64 base+index*scale+displace] - implement by building a
;; 'normalize' function that converts it to our current format.
;;   * use m64/m32/m16/m8, not qword/dword/etc
;;   * make sure it works with different orders like index*scale+base+displace
;;   * make sure it works in simplified forms like base+displace

;; TODO: imm* macros should accept [label-rel-ref foo] and [label-abs-ref foo] and expand into the
;; appropriate label: [imm 32 [label-rel-ref foo]] should expand into [label-rel-ref foo 4 LE]
;;
;; This is needed so that if you specify [mov rdi [label-rel-ref foo]] it works.
;; This also means the assembler needs to recognize "label-rel-ref" things as imm*
;; values when looking up instructions.

;; TODO accessory functions we don't want to publicly expose can be hidden by including them
;; in the public function that uses them and calling them with a label.

;; TODO: imm* macros should accept stuff like [imm 64 0xFF] along with base 10 version.
;; [imm 64 0cb] for chars? [imm 64 'b']?
;;  Would just need to change the parse-int function.
;; default to base 10.
;; TODO: show usage w/ "Usage:" for all functions/macros above them

[[data imm-arg-count-error   "\nERROR: Incorrect number of parameters passed to imm [should be 2].\n"]
 [data imm-bad-width-error   "\nERROR: Bad width as first arg to imm. Must be one of: 8 16 32 64.\n"]
 [data imm-bad-input-error   "\nERROR: Bad input to imm.\n"]
 [data REX-input-error       "\nERROR: Inputs to REX must be one char each of: WRXBwrxb.\n"]
 [data MODRM-input-error     "\nERROR: Bad input to RM\n"]
 [data memop-error           "\nERROR: Incorrectly formatted or unsupported memory operand.\n"]
 [data reg-name-to-num-not-found-error "ERROR: invalid register specified\n"]
 [data bregnum-bad-use-error "\nERROR: Invalid use of of bregnum. Try [bregnum register-name].\n"]

 [data MODRM-reg        "reg"]
 [data MODRM-mem        "mem"]
 [data MODRM-mem+disp8  "mem+disp8"]
 [data MODRM-mem+disp32 "mem+disp32"]

 [data regname-rbp rbp]
 [data regname-r13 r13]

 [data zero 0]

 [data barray-cat-macro-name "bb/barray-cat"]
 [data label-scope-name "label-scope"]

 [data valid-registers [rax eax   ax    al
                        rcx ecx   cx    cl
                        rdx edx   dx    dl
                        rbx ebx   bx    bl
                        rsp esp   sp    spl
                        rbp ebp   bp    bpl
                        rsi esi   si    sil
                        rdi edi   di    dil

                        ;; Extended registers, use REX prefix to access
                        r8  r8d   r8w   r8b
                        r9  r9d   r9w   r9b
                        r10 r10d  r10w  r10b
                        r11 r11d  r11w  r11b
                        r12 r12d  r12w  r12b
                        r13 r13d  r13w  r13b
                        r14 r14d  r14w  r14b
                        r15 r15d  r15w  r15b]]

 [data reg-num-map [[rax "\x00"] [eax  "\x00"] [ax   "\x00"] [al   "\x00"]
                    [rcx "\x01"] [ecx  "\x01"] [cx   "\x01"] [cl   "\x01"]
                    [rdx "\x02"] [edx  "\x02"] [dx   "\x02"] [dl   "\x02"]
                    [rbx "\x03"] [ebx  "\x03"] [bx   "\x03"] [bl   "\x03"]
                    [rsp "\x04"] [esp  "\x04"] [sp   "\x04"] [spl  "\x04"]
                    [rbp "\x05"] [ebp  "\x05"] [bp   "\x05"] [bpl  "\x05"]
                    [rsi "\x06"] [esi  "\x06"] [si   "\x06"] [sil  "\x06"]
                    [rdi "\x07"] [edi  "\x07"] [di   "\x07"] [dil  "\x07"]

                    ;; Extended registers, use REX prefix to access
                    [r8  "\x00"] [r8d  "\x00"] [r8w  "\x00"] [r8b  "\x00"]
                    [r9  "\x01"] [r9d  "\x01"] [r9w  "\x01"] [r9b  "\x01"]
                    [r10 "\x02"] [r10d "\x02"] [r10w "\x02"] [r10b "\x02"]
                    [r11 "\x03"] [r11d "\x03"] [r11w "\x03"] [r11b "\x03"]
                    [r12 "\x04"] [r12d "\x04"] [r12w "\x04"] [r12b "\x04"]
                    [r13 "\x05"] [r13d "\x05"] [r13w "\x05"] [r13b "\x05"]
                    [r14 "\x06"] [r14d "\x06"] [r14w "\x06"] [r14b "\x06"]
                    [r15 "\x07"] [r15d "\x07"] [r15w "\x07"] [r15b "\x07"]]]

 [data reg-is-ext-list [r8   r8d   r8w   r8b
                        r9   r9d   r9w   r9b
                        r10  r10d  r10w  r10b
                        r11  r11d  r11w  r11b
                        r12  r12d  r12w  r12b
                        r13  r13d  r13w  r13b
                        r14  r14d  r14w  r14b
                        r15  r15d  r15w  r15b]]

 ;; Encodings are defined with a mini-DSL composed of macros. This allows for arbitrarily complex
 ;; behavior in encoding each form [if you need a new behavior, implement a new macro].
 ;;
 ;; X86_64 is a mess and pretty inconsistent with plenty of special cases, so this level
 ;; of flexibility is needed to nicely handle all cases.
 ;;
 ;; The encoding process is to simply:
 ;;   * push some relevant macros to the stack
 ;;   * macroexpand your encoding
 ;;   * pop those extra macros.
 ;;
 ;; Entry format:
 ;; [instruction-name [[[accepted types for param 0] [accepted types for param 1]] encoding]
 ;;                    [another possible encoding]]
 ;;
 ;; barrays in your encoding will be forward directly, so use byte strings to provide literals.
 ;;
 ;; Operand types:
 ;; re*   = extended register
 ;; r*    = non-extended register
 ;; m*    = memory operand
 ;; me*   = memory operand using extended registers [base or index]
 ;; s8    = spl, bpl, sil, or dil [these registers have special encoding rules]
 ;; l8    = legacy ah, bh, ch, dh [we don't actually support this but writing it down in case we ever add it]
 ;; imm*  = immediate values
 ;; label = labels. Use them with label-rel-ref and label-abs-ref.
 ;;
 ;; Some relevant macros [though if you need something more - just define a new macro]
 ;;   * [REX [W] [R] [X] [B]]             - encodes a REX byte
 ;;   * [RM reg reg/mem]                  - encode a MODRM, SIB, and displacement
 ;;   * [imm 8], [imm 16], [imm 32], [imm 64] - encodes immediate values
 ;;
 ;; p macro represents parameters. [p *] expands to the parameter [memory operand, register etc]
 ;;
 ;; Tips:
 ;;   * The bb/bsumLE macro with bregnum can be used to offset base opcodes with a register num
 ;;   * The if-ext macro can be used to set REX byte flags.
 ;;   * The memop-base macro can be used to get the base register for memory operands
 ;;   * The memop-index macro can be used to get the index register for memory operands
 ;;
 ;; Conventions
 ;;   * Any instruction that accepts a label should have an "abs" or "rel" suffix depending on if
 ;;     we access the label absolutely or relatively.
 ;;   * Any instruction that has relative or absolute modes should have an "abs" or "rel" suffix.

 [noexpand-data instruction-table
  [[mov      [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x8B" [RM [p 0] [p 1]]]
             [[[r64 re64] [m64 me64]] [REX W [if-ext [p 0] R] [if-ext [memop-index [p 1]] X] [if-ext [memop-base [p 1]] B]] "\x8B" [RM [p 0] [p 1]]]
             [[[m64 me64] [r64 re64]] [REX W [if-ext [p 1] R] [if-ext [memop-index [p 0]] X] [if-ext [memop-base [p 0]] B]] "\x89" [RM [p 1] [p 0]]]
             [[[r64 re64] [imm32   ]] [REX W [if-ext [p 0] B]] "\xC7" [RM 0 [p 0]] [imm 32 [p 1]]]
             [[[r64 re64] [imm64   ]] [REX W [if-ext [p 0] B]] [bb/bsumLE "\xB8" [bregnum [p 0]]] [imm 64 [p 1]]]
             [[[s8      ] [m8   me8]] [REX [if-ext [memop-index [p 1]] X] [if-ext [memop-base [p 1]] B]] "\x8A" [RM [p 0] [p 1]]]]
   [add      [[[r64 re64] [imm8    ]] [REX W [if-ext [p 0] B]] "\x83" [RM 0 [p 0]][imm 8 [p 1]]]
             [[[m64 me64] [imm8    ]] [REX W [if-ext [memop-index [p 0]] X] [if-ext [memop-base [p 0]] B]] "\x83" [RM 0 [p 0]] [imm 8 [p 1]]]
             [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x03" [RM [p 0] [p 1]]]]
   [sub      [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x2B" [RM [p 0] [p 1]]]
             [[[r64 re64] [imm8    ]] [REX W [if-ext [p 0] B]] "\x83" [RM 5 [p 0]] [imm 8 [p 1]]]]
   [syscall  [[                     ] "\x0F\x05"]]
   [mov-abs  [[[r64 re64] [label   ]] [REX W [if-ext [p 0] B]] [bb/bsumLE "\xB8" [bregnum [p 0]]] [label-abs-ref [p 1] 8 LE]]
             [[[r64 re64] [imm64   ]] [REX W [if-ext [p 0] B]] [bb/bsumLE "\xB8" [bregnum [p 0]]] [imm 64 [p 1]]]]
   [mov-rel  [[[r64 re64] [label   ]] [REX W [if-ext [p 0] B]] [bb/bsumLE "\xB8" [bregnum [p 0]]] [label-rel-ref [p 1] 8 LE]]]
   [cmova    [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x0F\x47" [RM [p 0] [p 1]]]]
   [cmp      [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x3B" [RM [p 0] [p 1]]]
             [[[r64 re64] [imm8    ]] [REX W [if-ext [p 0] B]] "\x83" [RM 7 [p 0]] [imm 8 [p 1]]]
             [[[m64 me64] [imm8    ]] [REX W [if-ext [memop-index [p 0]] X] [if-ext [memop-base [p 0]] B]] "\x83" [RM 7 [p 0]] [imm 8 [p 1]]]
             [[[m8   me8] [imm8    ]] [REX [if-ext [memop-index [p 0]] X] [if-ext [memop-base [p 0]] B]] "\x80" [RM 7 [p 0]] [imm 8 [p 1]]]]
   [je-rel   [[[label   ]           ] "\x0F\x84" [label-rel-ref [p 0] 4 LE]]]
   [jne-rel  [[[label   ]           ] "\x0F\x85" [label-rel-ref [p 0] 4 LE]]]
   [jg-rel   [[[label   ]           ] "\x0F\x8F" [label-rel-ref [p 0] 4 LE]]]
   [jle-rel  [[[label   ]           ] "\x0F\x8E" [label-rel-ref [p 0] 4 LE]]]
   [jmp-rel  [[[label   ]           ] "\xE9" [label-rel-ref [p 0] 4 LE]]]
   [xor      [[[r64 re64] [r64 re64]] [REX W [if-ext [p 0] R] [if-ext [p 1] B]] "\x33" [RM [p 0] [p 1]]]]
   [mul      [[[r64 re64]           ] [REX W [if-ext [p 0] B]] "\xF7" [RM 4 [p 0]]]]
   [push     [[[r64 re64]           ] [if-ext [p 0] [REX B]] [bb/bsumLE "\x50" [bregnum [p 0]]]]]
   [pop      [[[r64 re64]           ] [if-ext [p 0] [REX B]] [bb/bsumLE "\x58" [bregnum [p 0]]]]]
   [ret      [[                     ] "\xC3"]]
   [dec      [[[r64 re64]           ] [REX W [if-ext [p 0] B]] "\xFF" [RM 1 [p 0]]]
             [[[m64 me64]           ] [REX W [if-ext [memop-index [p 0]] X] [if-ext [memop-base [p 0]] B]] "\xFF" [RM 1 [p 0]]] ]
   [not      [[[r64 re64]           ] [REX W [if-ext [p 0] B]] "\xF7" [RM 2 [p 0]]]]
   [neg      [[[r64 re64]           ] [REX W [if-ext [p 0] B]] "\xF7" [RM 3 [p 0]]]]
   [call-abs [[[r64 re64]           ] [if-ext [p 0] [REX B]] "\xFF"[RM 2 [p 0]]]]]]

 ;; writes a barray's bytes to fd [use me to print stuff to stdout/stderr]
 [data write-barray-to-fd-fn
  [bb/barray-cat
   "\x41\x54"                                   ; push r12
   "\x41\x55"                                   ; push r13
   "\x41\x56"                                   ; push r14

   "\x49\x89\xFD"                               ; mov r13, rdi        - barray
   "\x49\x89\xF6"                               ; mov r14, rsi        - fd

   "\x4D\x8B\x65\x00"                           ; mov r12, qword[r13] - r12 = string length
   "\x49\x83\xC5\x08"                           ; add r13, 8          - move past length

   [label write-loop]
   [label-scope
    "\x4C\x89\xE2"                              ; mov rdx, r12        - String length
    "\x4C\x89\xEE"                              ; mov rsi, r13        - String
    "\x4C\x89\xF7"                              ; mov rdi, r14        - Output fd
    "\x48\xC7\xC0\x01\x00\x00\x00"              ; mov rax, 1          - sys_write
    "\x0F\x05"                                  ; syscall

    "\x48\x83\xF8\x00"                          ; cmp rax, 0
    "\x0F\x8C" [label-rel-ref write-err 4 LE]   ; jl write-err

    "\x49\x29\xC4"                              ; sub r12, rax
    "\x49\x01\xC5"                              ; add r13, rax
    "\x49\x83\xFC\x00"                          ; cmp r12, 0
    "\x0F\x8F" [label-rel-ref write-loop 4 LE]] ; jg write-loop

   [label epilogue]
   "\x41\x5E"                                   ; pop r14
   "\x41\x5D"                                   ; pop r13
   "\x41\x5C"                                   ; pop r12
   "\xC3"                                       ; ret

   [label write-err]
   "\x48\xC7\xC0\x00\x00\x00\x00"               ; mov rax, 0
   "\xE9" [label-rel-ref epilogue 4 LE]]]       ; jmp epilogue


 ;; Prints the error barray to stderr [rdi] and exits
 ;; TODO what exit code? we want to make sure it's != 0
 [data error-exit-fn
  [bb/barray-cat
   ; rdi is already correct
   "\x48\xC7\xC6\x02\x00\x00\x00"                          ; mov rsi, 2 - we want stderr
   "\x48\xB8" [write-barray-to-fd-fn barray-raw-addr 8 LE] ; mov rax, write-barray-to-fd
   "\xFF\xD0"                                              ; call rax

   "\x48\xC7\xC0\x3C\x00\x00\x00"                          ; mov rax, 60 - sys_exit
   "\x0F\x05"                                              ; syscall
   "\xC3"]]                                                ; ret

 ;; Outputs a register number given a barray input [rdi] of a register name
 ;;
 ;; Note: due to the way extended registers work, there are multiple registers with the same
 ;; number. R8 number == rax number for example. See reg-num-map.
 [data reg-name-to-num
  [bb/barray-cat
   "\x41\x54"     ; push r12
   "\x41\x55"     ; push r13
   "\x41\x56"     ; push r14
   "\x41\x57"     ; push r15
   "\x53"         ; push rbx

   "\x49\x89\xFC"                    ; mov r12, rdi
   "\x49\xBE"[reg-num-map addr 8 LE] ; mov r14, reg-num-map
   "\x4D\x8B\x2E"                    ; mov r13, qword[r14]
   "\x49\xF7\xD5"                    ; not r13 - r13 = table entry count
   "\x49\x83\xC6\x08"                ; add r14, 8 - move past length

   ;; Iterate over reg-num-map
   [label table-loop]
   [label-scope
    "\x49\x83\xFD\x00" ; cmp r13, 0
    "\x0F\x8E"[label-rel-ref table-loop-break 4 LE] ; jle table-loop-break

    "\x4D\x8B\x3E" ; mov r15, qword[r14] - r15 = pointer to table entry

    "\x4C\x89\xE7"                                       ; mov rdi, r12
    "\x49\x8B\x77\x08"                                   ; mov rsi, qword[r15+8]
    "\x48\xB8"[bb/builtin-func-addr/barray-equalp]    ; mov rax, barray-equalp
    "\xFF\xD0"                                           ; call rax
    "\x48\x83\xF8\x01" ; cmp rax, 1
    "\x49\x8B\x7F\x10" ; mov rdi, qword[r15+16]
    "\xB8\x00\x00\x00\x00" ; mov rax, 0
    "\x8A\x47\x08" ; mov al, byte[rdi+8]
    "\x0F\x84" [label-rel-ref table-loop-found 4 LE] ; je table-loop-found

    "\x49\x83\xC6\x08" ; add r14, 8
    "\x49\xFF\xCD"     ; dec r13
    "\xE9" [label-rel-ref table-loop 4 LE]] ; jmp table-loop
   [label table-loop-break]

   ;; Error if we get here, didn't find a match
   "\x48\xBF" [reg-name-to-num-not-found-error addr 8 LE] ; mov rdi, error
   "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]        ; mov rax, error-exit-fn
   "\xFF\xD0"                                             ; call rax

   [label table-loop-found]

   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]   ; ret                                        ; ret 

 ;; Converts a single ascii char to the digit it represents. Works up to base 36.
 [data ascii-to-digit-fn
  [bb/barray-cat
   "\x48\x89\xF8"                                      ; mov rax, rdi

   "\x48\x83\xF8\x39"                                  ; cmp rax, 57
   "\x0F\x8F" [label-rel-ref as-uppercase-letter 4 LE] ; jg as-uppercase-letter

   "\x48\x83\xE8\d048"                                 ; sub rax, 48
   "\xC3"                                              ; ret

   [label as-uppercase-letter]
   "\x48\x83\xF8\d090"                                 ; cmp rax, 90
   "\x0F\x8F" [label-rel-ref as-lowercase-letter 4 LE] ; jg as-lowercase-letter

   "\x48\x83\xE8\d055"                                 ; sub rax, 55
   "\xC3"                                              ; ret

   [label as-lowercase-letter]
   "\x48\x83\xE8\d087"                                 ; sub rax, 87
   "\xC3"]]                                            ; ret

 ;; parses a signed ascii integer from barray in rdi assuming it is in base rsi
 [data parse-int-fn
  [bb/barray-cat
   "\x41\x54"     ; push r12
   "\x41\x55"     ; push r13
   "\x41\x56"     ; push r14
   "\x41\x57"     ; push r15
   "\x53"         ; push rbx

   "\x49\x89\xFC" ; mov r12, rdi - r12 = input barray
   "\x49\x89\xF5" ; mov r13, rsi - r13 = base

   "\x4D\x8B\x3C\x24"     ; mov r15, qword[r12] - r15 = barray length
   "\x49\x83\xC4\x08"     ; add r12, 8 - move past length

   ;; Loop working right-to-left
   "\x4D\x31\xF6"                 ; xor r14, r14 - result
   "\x48\xC7\xC3\x01\x00\x00\x00" ; mov rbx, 1   - multiplier

   [label loop]
   [label-scope
    "\x49\x83\xFF\x00"                         ; cmp r15, 0
    "\x0F\x84" [label-rel-ref loop-break 4 LE] ; je loop-break

    ;; If r15 == 1 [the last char], and the char is '-', take the two's complement of
    ;; the result and break the loop.
    "\x49\x83\xFF\x01"                      ; cmp r15, 1
    "\x0F\x85" [label-rel-ref not-neg 4 LE] ; jne not-neg
    "\x43\x80\x7c\x3c\xff\x2d"              ; cmp byte[r12+r15-1], '-'
    "\x0F\x85" [label-rel-ref not-neg 4 LE] ; jne not-neg

    "\x49\xF7\xDE"                         ; neg r14
    "\xE9" [label-rel-ref loop-break 4 LE] ; jmp loop-break

    [label not-neg]

    ;; Parse digit
    "\x48\x31\xFF"         ; xor rdi, rdi
    "\x43\x8A\x7C\x3C\xFF" ; mov dil, byte[r12+r15-1]
    "\x48\xB8" [ascii-to-digit-fn barray-raw-addr 8 LE]  ; mov rax, ascii-to-digit-fn
    "\xFF\xD0"                                                   ; call rax

    ;; TODO error if digit >= base?
    ;; TODO error if digit < 0?

    "\x48\xF7\xE3" ; mul rbx - multiply digit by multiplier
    "\x49\x01\xC6" ; add r14, rax - add to result

    ;; Update multiplier
    "\x48\x89\xD8" ; mov rax, rbx
    "\x49\xF7\xE5" ; mul r13
    "\x48\x89\xC3" ; mov rbx, rax

    "\x49\xFF\xCF" ; dec r15
    "\xE9" [label-rel-ref loop 4 LE]] ; jmp loop
   [label loop-break]

   "\x4C\x89\xF0" ; mov rax, r14
   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]   ; ret

 ;; Attempts to write MODRM and associated bytes for a rip-rel RM encoding.
 ;;   * rdi = normalized memory operand [m* base index scale disp], rsi = output byte buffer
 ;;   * reg field will be 0.
 ;;   * returns 1 [on success] or 0 [not possible to encode this memory operand as rip-rel]
 [data RM-try-encode-rip-rel-fn
  [bb/barray-cat
   "\x41\x54" ; push r12
   "\x41\x55" ; push r13
   "\x41\x56" ; push r14

   "\x49\x89\xFC" ; mov r12, rdi - memory operand
   "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

   ;; We can use rip-rel if base == ascii_0 && index == ascii_0

   ;; If our input is not a parray of length 5, goto nope
   "\x49\x83\x3C\x24\xFA"               ; cmp qword[r12], -6
   "\x0F\x85" [label-rel-ref nope 4 LE] ; jne nope

   ;; If 'base' is not a barray of length one, goto nope
   "\x49\x8B\x7C\x24\x10"               ; mov rdi, qword[r12+16]
   "\x48\x83\x3F\x01"                   ; cmp qword[rdi], 1
   "\x0F\x85" [label-rel-ref nope 4 LE] ; jne nope

   ;; If the 'base' byte is not ascii '0', goto nope
   "\x49\x8B\x7C\x24\x10"               ; mov rdi, qword[r12+16]
   "\x80\x7F\x08\x30"                   ; cmp byte[rdi+8], '0'
   "\x0F\x85" [label-rel-ref nope 4 LE] ; jne nope

   ;; If 'index' is not a barray of length one, goto nope
   "\x49\x8B\x7C\x24\x18"               ; mov rdi, qword[r12+24]
   "\x48\x83\x3F\x01"                   ; cmp qword[rdi], 1
   "\x0F\x85" [label-rel-ref nope 4 LE] ; jne nope

   ;; If the 'index' byte is not ascii '0', goto nope
   "\x49\x8B\x7C\x24\x18"               ; mov rdi, qword[r12+24]
   "\x80\x7F\x08\x30"                   ; cmp byte[rdi+8], '0'
   "\x0F\x85" [label-rel-ref nope 4 LE] ; jne nope

   ;; If 'disp' is not a barray, goto nope
   "\x49\x8B\x7C\x24\x28"              ; mov rdi, qword[r12+40]
   "\x48\x83\x3F\x00"                  ; cmp qword[rdi], 0
   "\x0F\x8C"[label-rel-ref nope 4 LE] ; jl nope

   ;; If we get here, encode the rip-rel MODRM form

   ;; Push a byte of value '5' for MODRM
   "\x4C\x89\xEF"                                             ; mov rdi, r13
   "\xBE\x05\x00\x00\x00"                                     ; mov rsi, 5
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8]  ; mov rax, bb_push_int8
   "\xFF\xD0"                                                 ; call rax

   ;; Parse our displacement integer
   "\x49\x8B\x7C\x24\x28"                         ; mov rdi, qword[r12+40]
   "\xBE\x0A\x00\x00\x00"                         ; mov rsi, 10
   "\x48\xB8"[parse-int-fn barray-raw-addr 8 LE]  ; mov rax, parse-int-fn
   "\xFF\xD0"                                     ; call rax

   ;; Push our displacement integer as int32
   "\x4C\x89\xEF" ; mov rdi, r13
   "\x48\x89\xC6" ; mov rsi, rax
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int32] ; mov rax, bb_push_int32
   "\xFF\xD0"                                                 ; call rax

   "\x48\xC7\xC0\x01\x00\x00\x00"       ; mov rax, 1
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue

   [label nope]
   "\x48\xC7\xC0\x00\x00\x00\x00"       ; mov rax, 0

   [label epilogue]
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]   ; ret

 ;; Returns 1 if the register name barray [rdi] is a valid register name, else 0
 [data valid-register-name-p-fn
  [bb/barray-cat
   "\x41\x54" ; push r12
   "\x41\x55" ; push r13
   "\x41\x56" ; push r14
   "\x41\x57" ; push r15
   "\x53"     ; push rbx

   "\x49\x89\xFC" ; mov r12, rdi - register name barray

   "\x49\xBD"[valid-registers addr 8 LE] ; mov r13, valid-registers
   "\x4D\x8B\x75\x00"                    ; mov r14, qword[r13]
   "\x49\xF7\xD6"                        ; not r14 - r14 = parray length
   "\x49\x83\xC5\x08"                    ; add r13, 8 - move past length

   [label regloop]
   [label-scope
    "\x49\x83\xFE\x00" ; cmp r14, 0
    "\x0F\x8E"[label-rel-ref regloop-break 4 LE] ; jle regloop-break

    "\x49\x8B\x7D\x00"                                ; mov rdi, qword[r13] - rdi = reg barray*
    "\x4C\x89\xE6"                                    ; mov rsi, r12 - rsi = user input barray
    "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
    "\xFF\xD0"                                        ; call rax
    "\x48\x83\xF8\x01"                                ; cmp rax, 1
    "\x0F\x84"[label-rel-ref found 4 LE]              ; je found

    "\x49\x83\xC5\x08" ; add r13, 8
    "\x49\xFF\xCE" ; dec r14

    "\xE9" [label-rel-ref regloop 4 LE]] ; jmp regloop
   [label regloop-break]

   "\xB8\x00\x00\x00\x00"               ; mov rax, 0
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue

   [label found]
   "\xB8\x01\x00\x00\x00" ; mov rax, 1

   [label epilogue]
   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]

 ;; Attempts to write MODRM and associated bytes for a straight mem [no disp/SIB] RM encoding.
 ;;   * rdi = normalized memory operand [m* base index scale disp], rsi = output byte buffer
 ;;   * reg field will be 0.
 ;;   * returns 1 [on success] or 0 [not possible to encode this memory operand as straight mem]
 [data RM-try-encode-mem-fn
  [bb/barray-cat
   "\x41\x54" ; push r12
   "\x41\x55" ; push r13
   "\x41\x56" ; push r14
   "\x41\x57" ; push r15
   "\x53"     ; push rbx

   "\x49\x89\xFC" ; mov r12, rdi - memory operand
   "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

   ;; If base != ascii_0 && base != rbp_or_r13 && base != register_4 &&
   ;; index == ascii_0 && displace == 0, we can encode this memory operand without a
   ;; displacement or SIB byte with mod 00.

   ;; If our input is not a parray of length 5, goto nope
   "\x49\x83\x3C\x24\xFA"              ; cmp qword[r12], -6
   "\x0F\x85"[label-rel-ref nope 4 LE] ; jne nope

   ;; If base isn't a valid register name, goto nope
   "\x49\x8B\x7C\x24\x10"                                     ; mov rdi, qword[r12+16]
   "\x48\xB8" [valid-register-name-p-fn barray-raw-addr 8 LE] ; mov rax, valid-register-name-p
   "\xFF\xD0"                                                 ; call rax
   "\x48\x83\xF8\x01"                                         ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]                       ; jne nope

   ;; If base == rbp, goto nope
   "\x49\x8B\x7C\x24\x10"                            ; mov rdi, qword[r12+16]
   "\x48\xBE"[regname-rbp addr 8 LE]                 ; mov rsi, regname-rbp
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x84" [label-rel-ref nope 4 LE]              ; je nope

   ;; If base == r13, goto nope
   "\x49\x8B\x7C\x24\x10"                            ; mov rdi, qword[r12+16]
   "\x48\xBE"[regname-r13 addr 8 LE]                 ; mov rsi, regname-r13
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x84" [label-rel-ref nope 4 LE]              ; je nope

   ;; If reg-name-to-num[base] == 4, goto nope [we can't do rsp and friends]
   "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x48\x83\xF8\x04"                               ; cmp rax, 4
   "\x0F\x84" [label-rel-ref nope 4 LE]              ; je nope

   ;; If index != ascii '0', goto nope
   "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
   "\x48\xBE"[zero addr 8 LE]                        ; mov rsi, zero
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]              ; jne nope

   ;; If displace != ascii '0', goto nope
   "\x49\x8B\x7C\x24\x28"                            ; mov rdi, qword[r12+40]
   "\x48\xBE"[zero addr 8 LE]                        ; mov rsi, zero
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]              ; jne nope

   ;; If we get here, encode our MODRM. Just write a byte for the register number in 'base'
   "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax

   "\x4C\x89\xEF"                                            ; mov rdi, r13
   "\x48\x89\xC6"                                            ; mov rsi, rax
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_byte
   "\xFF\xD0"                                                ; call rax

   "\xB8\x01\x00\x00\x00" ; mov rax, 1
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue
   [label nope]
   "\x48\xC7\xC0\x00\x00\x00\x00"       ; mov rax, 0

   [label epilogue]
   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]   ; ret

 [data RM-try-encode-mem+disp-fn
  [bb/barray-cat
   "\x41\x54" ; push r12
   "\x41\x55" ; push r13
   "\x41\x56" ; push r14
   "\x41\x57" ; push r15
   "\x53"     ; push rbx

   "\x49\x89\xFC" ; mov r12, rdi - memory operand
   "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

   ;; If base != ascii_0 && base != register_4 && index == ascii_0, we can encode this memory
   ;; operand with mem+disp with mod 01 or mod 10 depending on displacement size.

   ;; If our input is not a parray of length 5, goto nope
   "\x49\x83\x3C\x24\xFA"              ; cmp qword[r12], -6
   "\x0F\x85"[label-rel-ref nope 4 LE] ; jne nope

   ;; If base isn't a valid register name, goto nope
   "\x49\x8B\x7C\x24\x10"                                     ; mov rdi, qword[r12+16]
   "\x48\xB8" [valid-register-name-p-fn barray-raw-addr 8 LE] ; mov rax, valid-register-name-p
   "\xFF\xD0"                                                 ; call rax
   "\x48\x83\xF8\x01"                                         ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]                       ; jne nope

   ;; If reg-name-to-num[base] == 4, goto nope [we can't do rsp and friends]
   "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x48\x83\xF8\x04"                               ; cmp rax, 4
   "\x0F\x84" [label-rel-ref nope 4 LE]             ; je nope

   ;; If index != ascii '0', goto nope
   "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
   "\x48\xBE"[zero addr 8 LE]                        ; mov rsi, zero
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]              ; jne nope

   ;; We can encode it. Will be disp8 or disp32 depending on displacement size

   ;; Work out the register number of our base
   "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x49\x89\xC7"                                   ; mov r15, rax

   ;; Parse displacement int
   "\x49\x8B\x7C\x24\x28"                        ; mov rdi, qword[r12+40]
   "\xBE\x0A\x00\x00\x00"                        ; mov rsi, 10
   "\x48\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
   "\xFF\xD0"                                    ; call rax
   "\x49\x89\xC6"                                ; mov r14, rax

   ;; If displacement is too large for disp8, jump to disp32
   "\x48\x83\xF8\x7F"                     ; cmp rax, 127
   "\x0F\x8F" [label-rel-ref disp32 4 LE] ; jg disp32
   "\x48\x83\xF8\x80"                     ; cmp rax, -128
   "\x0F\x8C" [label-rel-ref disp32 4 LE] ; jl disp32

   ;; Encode as disp8 [mod 01]
   "\xBE\x40\x00\x00\x00" ; mov rsi, 64
   "\x4C\x09\xFE"         ; or rsi, r15

   "\x4C\x89\xEF"                                             ; mov rdi, r13
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8]  ; mov rax, bb_push_int8
   "\xFF\xD0"                                                 ; call rax

   "\x4C\x89\xEF"                                             ; mov rdi, r13
   "\x4C\x89\xF6"                                             ; mov rsi, r14
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_int8
   "\xFF\xD0"                                                 ; call rax

   "\xB8\x01\x00\x00\x00" ; mov rax, 1
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue

   [label disp32]
   ;; Encode as disp32 [mod 10]
   "\xBE\x80\x00\x00\x00" ; mov rsi, 128
   "\x4C\x09\xFE"         ; or rsi, r15

   "\x4C\x89\xEF"                                             ; mov rdi, r13
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8]  ; mov rax, bb_push_int8
   "\xFF\xD0"                                                 ; call rax

   "\x4C\x89\xEF"                                             ; mov rdi, r13
   "\x4C\x89\xF6"                                             ; mov rsi, r14
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int32] ; mov rax, bb_push_int32
   "\xFF\xD0"                                                 ; call rax

   "\xB8\x01\x00\x00\x00" ; mov rax, 1
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue
   [label nope]
   "\x48\xC7\xC0\x00\x00\x00\x00" ; mov rax, 0

   [label epilogue]
   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]   ; ret

 [data RM-try-encode-mem+sib-fn
  [bb/barray-cat
   "\x41\x54" ; push r12
   "\x41\x55" ; push r13
   "\x41\x56" ; push r14
   "\x41\x57" ; push r15
   "\x53"     ; push rbx

   "\x49\x89\xFC" ; mov r12, rdi - memory operand
   "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

   ;; If base != ascii_0 && index != register_4, we can encode this memory operand
   ;; with an SIB byte [and displacement if present].

   ;; If our input is not a parray of length 5, goto nope
   "\x49\x83\x3C\x24\xFA"              ; cmp qword[r12], -6
   "\x0F\x85"[label-rel-ref nope 4 LE] ; jne nope

   ;; If base isn't a valid register name, goto nope
   "\x49\x8B\x7C\x24\x10"                                     ; mov rdi, qword[r12+16]
   "\x48\xB8" [valid-register-name-p-fn barray-raw-addr 8 LE] ; mov rax, valid-register-name-p
   "\xFF\xD0"                                                 ; call rax
   "\x48\x83\xF8\x01"                                         ; cmp rax, 1
   "\x0F\x85" [label-rel-ref nope 4 LE]                       ; jne nope

   ;; index != ascii_0 && If reg-name-to-num[index] == 4, goto nope [we can't do rsp and
       ;; friends for index]
   "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
   "\x48\xBE"[zero addr 8 LE]                        ; mov rsi, zero
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x84" [label-rel-ref is-zero 4 LE]           ; je is-zero

   "\x49\x8B\x7C\x24\x18"                           ; mov rdi, qword[r12+24]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x48\x83\xF8\x04"                               ; cmp rax, 4
   "\x0F\x84" [label-rel-ref nope 4 LE]             ; je nope
   [label is-zero]

   ;; If scale isn't 1, 2, 4 or 8, goto nope [anything else is invalid input]
   "\x49\x8B\x7C\x24\x20"                        ; mov rdi, qword[r12+32]
   "\xBE\x0A\x00\x00\x00"                        ; mov rsi, 10
   "\x48\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
   "\xFF\xD0"                                    ; call rax
   "\x48\x85\xC0"                                ; test rax, rax
   "\x0F\x84"[label-rel-ref nope 4 LE]           ; jz nope
   "\x48\x89\xC6"                                ; mov rsi, rax
   "\x48\xFF\xCE"                                ; dec rsi
   "\x48\x85\xF0"                                ; test rax, rsi
   "\x0F\x85"[label-rel-ref nope 4 LE]           ; jnz nope
   "\x48\x83\xF8\x08"                            ; cmp rax, 8
   "\x0F\x87"[label-rel-ref nope 4 LE]           ; ja nope

   ;; If we got here, we can do it!

   "\x41\xBE\x04\x00\x00\x00" ; mov r14, 4 - we will encode our MODRM byte here, 4 sets SIB mode
   "\x41\xBF\x00\x00\x00\x00" ; mov r15, 0 - we will encode our SIB byte here 2-3-3 S-I-B

   ;; Determine if we're doing disp0, disp8 or disp32.
   ;;   * update MODRM accordingly and emit the MODRM byte
   "\x49\x8B\x7C\x24\x28"                        ; mov rdi, qword[r12+40]
   "\xBE\x0A\x00\x00\x00"                        ; mov rsi, 10
   "\x48\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
   "\xFF\xD0"                                    ; call rax
   "\x48\x89\xC3"                                ; mov rbx, rax - rbx = displacement

   "\x48\x83\xFB\x00"                            ; cmp rbx, 0
   "\x0F\x84" [label-rel-ref disp-done 4 LE]     ; je disp-done
   "\x48\x83\xFB\x7F"                            ; cmp rbx, 127
   "\x0F\x8F" [label-rel-ref disp32 4 LE]        ; jg disp32
   "\x48\x83\xFB\x80"                            ; cmp rbx, -128
   "\x0F\x8C" [label-rel-ref disp32 4 LE]        ; jl disp32

   [label disp8]
   "\x41\x80\xCE\x40"                            ; or r14b, 64
   "\xE9" [label-rel-ref disp-done 4 LE]         ; jmp disp-done
   [label disp32]
   "\x41\x80\xCE\x80"                            ; or r14b, 128

   [label disp-done]

   "\x4C\x89\xEF"                                            ; mov rdi, r13
   "\x4C\x89\xF6"                                            ; mov rsi, r14
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_int8
   "\xFF\xD0"                                                ; call rax

   ;; Work out 'base' part of SIB
   "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x41\x08\xC7"                                   ; or r15b, al

   ;; Work out 'index' part of SIB
   ;;        * If index != ascii 0, it's a register name
   ;;        * If index == ascii 0, write 100 to the field [this is why no rsp and friends]
   "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
   "\x48\xBE"[zero addr 8 LE]                        ; mov rsi, zero
   "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
   "\xFF\xD0"                                        ; call rax
   "\x48\x83\xF8\x01"                                ; cmp rax, 1
   "\x0F\x84" [label-rel-ref index-none 4 LE]        ; je index-none

   ;; Index != ascii 0
   "\x49\x8B\x7C\x24\x18"                           ; mov rdi, qword[r12+24]
   "\x48\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
   "\xFF\xD0"                                       ; call rax
   "\x48\xC1\xE0\x03"                               ; shl rax, 3
   "\x41\x08\xC7"                                   ; or r15b, al

   "\xE9"[label-rel-ref index-done 4 LE]            ; jmp index-done
   [label index-none]

   ;; Index == ascii 0
   "\x40\xB7\x04"     ; mov dil, 4
   "\x40\xC0\xE7\x03" ; shl dil, 3
   "\x41\x08\xFF"     ; or r15b, dil

   [label index-done]

   ;; Work out 'scale' part of SIB
   "\x49\x8B\x7C\x24\x20"                        ; mov rdi, qword[r12+32]
   "\xBE\x0A\x00\x00\x00"                        ; mov rsi, 10
   "\x48\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
   "\xFF\xD0"                                    ; call rax
   "\x48\x0F\xBD\xC0"                            ; bsr rax, rax
   "\x48\xC1\xE0\x06"                            ; shl rax, 6
   "\x41\x08\xC7"                                ; or r15b, al

   ;; Emit the SIB byte
   "\x4C\x89\xEF"                                            ; mov rdi, r13
   "\x4C\x89\xFE"                                            ; mov rsi, r15
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_int8
   "\xFF\xD0"                                                ; call rax

   ;; Encode displacement accordingly in branches for disp0 disp8 disp32
   "\x48\x83\xFB\x00"                          ; cmp rbx, 0
   "\x0F\x84" [label-rel-ref disp-done-2 4 LE] ; je disp-done
   "\x48\x83\xFB\x7F"                          ; cmp rbx, 127
   "\x0F\x8F" [label-rel-ref disp32-2 4 LE]    ; jg disp32
   "\x48\x83\xFB\x80"                          ; cmp rbx, -128
   "\x0F\x8C" [label-rel-ref disp32-2 4 LE]    ; jl disp32

   [label disp8-2]
   "\x4C\x89\xEF"                                            ; mov rdi, r13
   "\x48\x89\xDE"                                            ; mov rsi, rbx
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_int8
   "\xFF\xD0"                                                ; call rax
   "\xE9" [label-rel-ref disp-done-2 4 LE]                   ; jmp disp-done
   [label disp32-2]
   "\x4C\x89\xEF"                                            ; mov rdi, r13
   "\x48\x89\xDE"                                            ; mov rsi, rbx
   "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-int32] ; mov rax, bb_push_int32
   "\xFF\xD0"                                                ; call rax

   [label disp-done-2]

   "\xB8\x01\x00\x00\x00" ; mov rax, 1
   "\xE9" [label-rel-ref epilogue 4 LE] ; jmp epilogue

   [label nope]
   "\x48\xC7\xC0\x00\x00\x00\x00" ; mov rax, 0

   [label epilogue]
   "\x5B"     ; pop rbx
   "\x41\x5F" ; pop r15
   "\x41\x5E" ; pop r14
   "\x41\x5D" ; pop r13
   "\x41\x5C" ; pop r12
   "\xC3"]]

 [data raw-imm-barray "raw-imm"]

 ;; Encodes imm literal from base-10 ASCII number
 ;; Usage: [imm width-in-bits base-10-ascii]
 ;; TODO: support labels with label-rel-ref and label-abs-ref forms by expanding into
 ;; the form barray-cat expects
 [macro imm
  [x86_64-linux
   [bb/barray-cat
    "\x55"                                                            ; push rbp
    "\x48\x89\xE5"                                                    ; mov rbp, rsp
    "\x41\x54"                                                        ; push r12
    "\x41\x55"                                                        ; push r13
    "\x41\x56"                                                        ; push r14
    "\x41\x57"                                                        ; push r15
    "\x53"                                                            ; push rbx
    "\x48\x83\xEC\x08"                                                ; sub rsp, 8

    "\x49\x89\xFD"                                                    ; mov r13, rdi
    "\x49\x89\xF4"                                                    ; mov r12, rsi

    ;; Error if wrong argument count [!= 3]
    "\x49\x83\x7D\x00\xFC"                                            ; cmp qword[r13], -4
    "\x0F\x84" [label-rel-ref good-arg-count 4 LE]                    ; je good-arg-count

    "\x48\xBF" [imm-arg-count-error addr 8 LE]                        ; mov rdi, error
    "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]                   ; mov rax, error-exit-fn
    "\xFF\xD0"                                                        ; call rax

    [label good-arg-count]

    ;; TODO error if either argument is a parray?
    ;;  * perhaps in parse-int

    ;; Create our tail macroexpansion
    "\x4C\x89\xEF"                                                    ; mov rdi, r13
    "\x4C\x89\xE6"                                                    ; mov rsi, r12
    "\xBA\x02\x00\x00\x00"                                            ; mov rdx, 2 - greedy
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand_tail
    "\xFF\xD0"                                                        ; call rax
    "\x49\x89\xC5"                                                    ; mov r13, rax


    ;; Grab our data length so we know where our data starts
    "\x4C\x89\xE7" ; mov rdi, r12
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]     ; mov rax, bb_get_data_len
    "\xFF\xD0"                                                       ; call rax
    "\x49\x89\xC7"                                                   ; mov r15, rax

    ;; Parse first item in parray as signed base 10 ASCII integer [our width]
    "\x49\x8B\x7D\x08"                                                ; mov rdi, qword[r13+8]
    "\x48\xC7\xC6\x0A\x00\x00\x00"                                    ; mov rsi, 10
    "\x48\xB8" [parse-int-fn barray-raw-addr 8 LE]                    ; mov rax, parse-int
    "\xFF\xD0"                                                        ; call rax
    "\x48\x89\xC3"                                                    ; mov rbx, rax

    ;; If 3rd item in parray is a barray, skip to barray logic
    "\x49\x8B\x7D\x10" ; mov rdi, qword[r13+16]
    "\x48\x83\x3F\x00" ; cmp qword[rdi], 0
    "\x0F\x8D"[label-rel-ref is-barray 4 LE] ; jge is-barray

    ;; It's a parray.
    ;; If it's not 2 elements long, error
    "\x49\x8B\x7D\x10" ; mov rdi, qword[r13+16]
    "\x48\x83\x3F\xFD" ; cmp qword[rdi], -3
    "\x0F\x84"[label-rel-ref good-len 4 LE] ; je good-len

    "\x48\xBF" [imm-bad-input-error addr 8 LE]                        ; mov rdi, error
    "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]                   ; mov rax, error-exit-fn
    "\xFF\xD0"                                                        ; call rax

    [label good-len]

    ;;; If it doesn't start with raw-imm as first element, error
    "\x49\x8B\x4D\x10" ; mov rcx, qword[r13+16]
    "\x48\x8B\x79\x08" ; mov rdi, qword[rcx+8]
    "\x48\xBE"[raw-imm-barray addr 8 LE] ; mov rsi, raw-imm-barray

    "\x48\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
    "\xFF\xD0"                                                        ; call rax
    "\x48\x83\xF8\x01"                                ; cmp rax, 1
    "\x0F\x84"[label-rel-ref good-name 4 LE]          ; je good-name

    "\x48\xBF" [imm-bad-input-error addr 8 LE]                        ; mov rdi, error
    "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]                   ; mov rax, error-exit-fn
    "\xFF\xD0"                                                        ; call rax

    [label good-name]

    ;;; If the 2nd element doesn't match our width, error
    "\x49\x8B\x4D\x10" ; mov rcx, qword[r13+16]
    "\x48\x8B\x71\x10" ; mov rsi, qword[rcx+16]
    "\x48\x89\xDF"     ; mov rdi, rbx
    "\x48\xC1\xEF\x03" ; shr rdi 3
    "\x48\x39\x3E"     ; cmp qword[rsi], rdi
    "\x0F\x84"[label-rel-ref good-width 4 LE]          ; je good-width

    "\x48\xBF" [imm-bad-input-error addr 8 LE]                        ; mov rdi, error
    "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]                   ; mov rax, error-exit-fn
    "\xFF\xD0"                                                        ; call rax

    [label good-width]

    ;;; output the 2nd element as our result
    "\x4C\x89\xE7" ; mov rdi, r12
    ; mov rsi, rsi
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-push-barray] ; mov rax, byte-buffer-push-barray
    "\xFF\xD0"                                                        ; call rax
     "\xE9" [label-rel-ref done 4 LE]                         ; jmp done

    [label is-barray]

    ;; Parse 3rd item in parray as signed base 10 ASCII integer
    "\x49\x8B\x7D\x10"                                                ; mov rdi, qword[r13+16]
    "\x48\xC7\xC6\x0A\x00\x00\x00"                                    ; mov rsi, 10
    "\x48\xB8" [parse-int-fn barray-raw-addr 8 LE]                    ; mov rax, parse-int
    "\xFF\xD0"                                                        ; call rax
    "\x48\x89\x45\xD0"                                                ; mov qword[rbp-48], rax

    ;; Output our integer depending on our first argument [element 2]
    "\x48\x83\xFB\x40"                                                ; cmp rbx, 64
    "\x0F\x84" [label-rel-ref int64 4 LE]                             ; je int64
    "\x48\x83\xFB\x20"                                                ; cmp rbx, 32
    "\x0F\x84" [label-rel-ref int32 4 LE]                             ; je int32
    "\x48\x83\xFB\x10"                                                ; cmp rbx, 16
    "\x0F\x84" [label-rel-ref int16 4 LE]                             ; je int16
    "\x48\x83\xFB\x08"                                                ; cmp rbx, 8
    "\x0F\x84" [label-rel-ref int8 4 LE]                              ; je int8

    ;; Error if we get here
    "\x48\xBF" [imm-bad-width-error addr 8 LE]                        ; mov rdi, error
    "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE]                   ; mov rax, error-exit-fn
    "\xFF\xD0"                                                        ; call rax

    [label int64]
    "\xBE\x08\x00\x00\x00"                                            ; mov rsi, 8
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int64]       ; mov rax, bb_push_int64
     "\xE9" [label-rel-ref output-ready 4 LE]                         ; jmp output-ready
    [label int32]
    "\xBE\x04\x00\x00\x00"                                            ; mov rsi, 4
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int32]       ; mov rax, bb_push_int32
     "\xE9" [label-rel-ref output-ready 4 LE]                         ; jmp output-ready
    [label int16]
    "\xBE\x02\x00\x00\x00"                                            ; mov rsi, 2
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int16]       ; mov rax, bb_push_int16
     "\xE9" [label-rel-ref output-ready 4 LE]                         ; jmp output-ready
    [label int8]
    "\xBE\x01\x00\x00\x00"                                            ; mov rsi, 1
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int8]        ; mov rax, bb_push_int8
     "\xE9" [label-rel-ref output-ready 4 LE]                         ; jmp output-ready
    [label output-ready]

    "\x50"                                                            ; push rax
    "\x48\x83\xEC\x08"                                                ; sub rsp, 8
    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int64]       ; mov rax, bb_push_int64
    "\xFF\xD0"                                                        ; call rax
    "\x48\x83\xC4\x08"                                                ; add rsp, 8
    "\x58"                                                            ; pop rax

    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x48\x8B\x75\xD0"                                                ; mov rsi, qword[rbp-48]
    "\xFF\xD0"                                                        ; call rax

    [label done]

    ;; Free our tail expansion
    ;"\x4C\x89\xFF"                                                    ; mov rdi, r15
    ;"\x48\xB8" [bb/builtin-func-addr/byte-buffer-free]             ; mov rax, bb_free
    ;"\xFF\xD0"                                                        ; call rax

    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]           ; mov rax, bb_get_buf
    "\xFF\xD0"                                                        ; call rax
    ; return rax

    "\x4C\x01\xF8" ; add rax, r15

    "\x48\x83\xC4\x08"                                                ; add rsp, 8
    "\x5B"                                                            ; pop rbx
    "\x41\x5F"                                                        ; pop r15
    "\x41\x5E"                                                        ; pop r14
    "\x41\x5D"                                                        ; pop r13
    "\x41\x5C"                                                        ; pop r12
    "\x5D"                                                            ; pop rbp
    "\xC3"]]]

 [macro REX
  [x86_64-linux
   [bb/barray-cat
    "\x55"                                                            ; push rbp
    "\x48\x89\xE5"                                                    ; mov rbp, rsp
    "\x41\x54"     ; push r12
    "\x41\x55"     ; push r13
    "\x41\x56"     ; push r14
    "\x41\x57"     ; push r15
    "\x53"         ; push rbx
    "\x48\x83\xEC\x08"                                                ; sub rsp, 8

    "\x49\x89\xFC"                 ; mov r12, rdi  - input structure
    "\x49\x89\xF5"                 ; mov r13, rsi  - output byte buffer
    "\x49\xC7\xC6\x40\x00\x00\x00" ; mov r14, 0x40 - init output number to 0100 0000

    ;; Create our tail macroexpansion
    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x4C\x89\xEE"                                                    ; mov rsi, r13
    "\xBA\x02\x00\x00\x00"                                            ; mov rdx, 2 - greedy
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand_tail
    "\xFF\xD0"                                                        ; call rax

    "\x4C\x8B\x38"     ; mov r15, qword[rax]
    "\x49\xF7\xD7"     ; not r15 - r15 = input parray length

    "\x48\x89\xC3"     ; mov rbx, rax
    "\x48\x83\xC3\x08" ; add rbx, 8 - move past length

    ;; Iterate over elements of our input structure excluding first
    [label element-loop]
    [label-scope
     "\x49\x83\xFF\x00" ; cmp r15, 0
     "\x0F\x84" [label-rel-ref element-loop-break 4 LE] ; je element-loop-break

     "\x48\x8B\x4B\x00" ; mov rcx, qword[rbx] - rcx = pointer to element
     "\x48\xC7\xC2"[imm 32 8] ; mov rdx, 8

     ;; if the element isn't a barray of length 1, error
     "\x48\x83\x39"[imm 8 1]                     ; cmp qword[rcx], 1
     "\x0F\x84" [label-rel-ref good-input 4 LE] ; je good-input

     "\x48\xBF" [REX-input-error addr 8 LE] ; mov rdi, REX-input-error
     "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0" ; call rax

     [label good-input]

     ;; If the barray is 'W' or 'w', set the 1st bit
     "\x80\x79\x08" W                       ; cmp byte[rcx+8], 'W'
     "\x0F\x84" [label-rel-ref is-w 4 LE]   ; je is-w
     "\x80\x79\x08" w                       ; cmp byte[rcx+8], 'w'
     "\x0F\x84" [label-rel-ref is-w 4 LE]   ; je is-w
     "\xE9" [label-rel-ref is-not-w 4 LE]   ; jmp is-not-w
     [label is-w]
     "\x49\x09\xD6"                         ; or r14, rdx
     "\xE9" [label-rel-ref continue 4 LE]   ; jmp continue
     [label is-not-w]

     "\x48\xD1\xEA" ; shr rdx

     ;; If the barray is 'R' or 'r', set the 2nd bit
     "\x80\x79\x08" R                       ; cmp byte[rcx+8], 'R'
     "\x0F\x84" [label-rel-ref is-r 4 LE]   ; je is-r
     "\x80\x79\x08" r                       ; cmp byte[rcx+8], 'r'
     "\x0F\x84" [label-rel-ref is-r 4 LE]   ; je is-r
     "\xE9" [label-rel-ref is-not-r 4 LE]   ; jmp is-not-r
     [label is-r]
     "\x49\x09\xD6"                         ; or r14, rdx
     "\xE9" [label-rel-ref continue 4 LE]   ; jmp continue
     [label is-not-r]

     "\x48\xD1\xEA" ; shr rdx

     ;; If the barray is 'X' or 'x', set the 3rd bit
     "\x80\x79\x08" X                       ; cmp byte[rcx+8], 'X'
     "\x0F\x84" [label-rel-ref is-x 4 LE]   ; je is-x
     "\x80\x79\x08" x                       ; cmp byte[rcx+8], 'x'
     "\x0F\x84" [label-rel-ref is-x 4 LE]   ; je is-x
     "\xE9" [label-rel-ref is-not-x 4 LE]   ; jmp is-not-x
     [label is-x]
     "\x49\x09\xD6"                         ; or r14, rdx
     "\xE9" [label-rel-ref continue 4 LE]   ; jmp continue
     [label is-not-x]

     "\x48\xD1\xEA" ; shr rdx

     ;; If the barray is 'B' or 'b', set the 4th bit
     "\x80\x79\x08" B                       ; cmp byte[rcx+8], 'B'
     "\x0F\x84" [label-rel-ref is-b 4 LE]   ; je is-b
     "\x80\x79\x08" b                       ; cmp byte[rcx+8], 'b'
     "\x0F\x84" [label-rel-ref is-b 4 LE]   ; je is-b
     "\xE9" [label-rel-ref is-not-b 4 LE]   ; jmp is-not-b
     [label is-b]
     "\x49\x09\xD6"                         ; or r14, rdx
     "\xE9" [label-rel-ref continue 4 LE]   ; jmp continue
     [label is-not-b]

     ;; If we get here, error
     "\x48\xBF" [REX-input-error addr 8 LE] ; mov rdi, REX-input-error
     "\x48\xB8" [error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0" ; call rax

     [label continue]
     "\x48\x83\xC3"[imm 8 8]                    ; add rbx, 8
     "\x49\xFF\xCF"                            ; dec r15
     "\xE9" [label-rel-ref element-loop 4 LE]] ; jmp element-loop
    [label element-loop-break]

    ;; Grab our data len so we know what to return later
    "\x4C\x89\xEF"                                                   ; mov rdi, r13
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]     ; mov rax, bb_get_data_len
    "\xFF\xD0"                                                       ; call rax
    "\x48\x89\x45\xD0"                                               ; mov qword[rbp-48], rax

    ;; Write our output number to output byte buffer as 1-byte barray
    "\x4C\x89\xEF" ; mov rdi, r13
    "\x48\xC7\xC6"[imm 32 1]                                      ; mov rsi, 1
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int64]  ; mov rax, bb_push_int64
    "\xFF\xD0"                                                   ; call rax

    "\x4C\x89\xEF" ; mov rdi, r13
    "\x4c\x89\xF6"                                               ; mov rsi, r14
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-push-int8]   ; mov rax, bb_push_byte
    "\xFF\xD0"                                                   ; call rax

    "\x4C\x89\xEF"                                                    ; mov rdi, r13
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]           ; mov rax, bb_get_buf
    "\xFF\xD0"                                                        ; call rax
    ; return rax

    "\x48\x03\x45\xD0" ; add rax, qword[rbp-48]

    "\x48\x83\xC4\x08"                                                ; add rsp, 8
    "\x5B"      ; pop rbx
    "\x41\x5F"  ; pop r15
    "\x41\x5E"  ; pop r14
    "\x41\x5D"  ; pop r13
    "\x41\x5C"  ; pop r12
    "\x5D"                                                            ; pop rbp
    "\xC3"]]]


 ;; Expands into MODRM + SIB + displacement bytes
 [macro RM
  [x86_64-linux
   [bb/barray-cat
    "\x55"                                                            ; push rbp
    "\x48\x89\xE5"                                                    ; mov rbp, rsp
    [REX B]"\x54"     ; push r12
    [REX B]"\x55"     ; push r13
    [REX B]"\x56"     ; push r14
    [REX B]"\x57"     ; push r15
    "\x53"            ; push rbx
    "\x48\x83\xEC\x08"                                                ; sub rsp, 8

    [REX W B]"\x89\xFC"   ; mov r12, rdi - input structure*
    [REX W B]"\x89\xF5"   ; mov r13, rsi - output byte buffer*

    ;; Create our tail macroexpansion
    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x4C\x89\xEE"                                                    ; mov rsi, r13
    "\xBA\x02\x00\x00\x00"                                            ; mov rdx, 2 - greedy
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand_tail
    "\xFF\xD0"                                                        ; call rax
    "\x49\x89\xC4"                                                    ; mov r12, rax

    ;; Grab our data len so we know what to return later
    "\x4C\x89\xEF"                                                   ; mov rdi, r13
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]     ; mov rax, bb_get_data_len
    "\xFF\xD0"                                                       ; call rax
    "\x48\x89\x45\xD0"                                               ; mov qword[rbp-48], rax

    ;; Write a placeholder output length
    [REX W R]"\x89\xEF"                                           ; mov rdi, r13
    [REX W]"\xC7\xC6"[imm 32 0]                                    ; mov rsi, 0
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64] ; mov rax, bb_push_int64
    "\xFF\xD0"                                                    ; call rax

    ;; Error if not exactly 2 elements in input structure: reg mem
    [REX W B]"\x83\x3C\x24"[imm 8 -3]              ; cmp qword[r12], -3
    "\x0F\x84"[label-rel-ref good-arg-count 4 LE] ; je good-arg-count

    [REX W]"\xBF"[MODRM-input-error addr 8 LE]        ; mov rdi, MODRM-input-error
    [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
    "\xFF\xD0"                                        ; call rax

    [label good-arg-count]

    ;; Our second argument is a bit complicated to encode.
    ;;   * If it's a barray, we're addressing a register, not a memory location
    ;;     * This can be encoded exactly like the previous argument, just don't bitshift
    ;;   * If it's a parray, we're addressing a memory location
    ;;     * We currently use the format [m64|m32|m16|m8 base index scale displace]
    ;;       * base is always a register
    ;;       * index is either ascii 0 or a register
    ;;       * scale is always base-10 ascii
    ;;       * displace is always base-10 ascii
    ;;     * We need to know exactly what registers we have for these encoding rules, not
    ;;       just the register number. Thus, inside the memory operand we only accept
    ;;       register names.
    ;;     * If base == ascii_0 && index == ascii_0, use abs32/rip-rel with displace val
    ;;     * If base != ascii_0 && base != rbp_or_r13 && base != register_4 &&
    ;;       index == ascii_0 && displace == 0, we can encode this memory operand without a
    ;;       displacement or SIB byte with mod 00.
    ;;     * If base != ascii_0 && base != register_4 && index == ascii_0 &&
    ;;       displacement < 128 && displacement >= -128, we can encode this memory operand
    ;;       with mem+disp8 with mod 01
    ;;     * If base != register_4 && index == ascii_0 && displacement < 2^31 &&
    ;;       displacement >= -2^31, we can encode this memory operand with mem+disp8 with
    ;;       mod 10
    ;;     * If base != ascii_0 && index != register_4, we can encode this memory operand
    ;;       with an SIB byte [and displacement if present].

    ;; If our 2nd argument - element 3 - is a barray, output a register for our second arg,
    ;; and set mod to 11
    [REX W B]"\x8B\x7C\x24"[imm 8 16]                 ; mov rdi, qword[r12+16]
    [REX W]"\x83\x3F"[imm 8 0]                        ; cmp qword[rdi], 0
    "\x0F\x8C"[label-rel-ref is-memory-operand 4 LE] ; jl is-memory-operand

    [label-scope
     [REX B]"\xB6"[imm 8 192] ; mov r14b, 192  - our output byte with mod 11 set

     ;; If element 2 is a barray of 1 byte and < 8, or the byte in
     [REX W B]"\x8B\x7C\x24"[imm 8 16]             ; mov rdi, qword[r12+16]
     [REX W]"\x83\x3F"[imm 8 1]                    ; cmp qword[rdi], 1
     "\x0F\x85" [label-rel-ref not-raw-byte 4 LE] ; jne not-raw-byte
     "\x80\x7F"[imm 8 8][imm 8 8]                   ; cmp byte[rdi+8], 8
     "\x0F\x8D"[label-rel-ref not-raw-byte 4 LE]  ; jge not-raw-byte
     "\x8A\x4F"[imm 8 8]                           ; mov cl, byte[rdi+8]
     [REX B]"\x08\xCE"                            ; or r14b, cl
     "\xE9"[label-rel-ref good-reg2 4 LE]   ; jmp good-reg2
     [label not-raw-byte]

     ;; If element 2 is a barray of 1 byte, >= 48 & <= 55, parse the ascii base-10
     ;; number, then or the byte in
     [REX W B]"\x8B\x7C\x24"[imm 8 16]                 ; mov rdi, qword[r12+16]
     [REX W]"\x83\x3F"[imm 8 1]                        ; cmp qword[rdi], 1
     "\x0F\x85"[label-rel-ref not-ascii-10 4 LE]     ; jne not-ascii-10
     "\x80\x7F"[imm 8 8][imm 8 48]                      ; cmp byte[rdi+8], 48
     "\x0F\x8C"[label-rel-ref not-ascii-10 4 LE]     ; jl not-ascii-10
     "\x80\x7F"[imm 8 8][imm 8 55]                      ; cmp byte[rdi+8], 55
     "\x0F\x8F"[label-rel-ref not-ascii-10 4 LE]     ; jg not-ascii-10
     [REX W]"\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
     "\xFF\xD0"                                       ; call rax - rdi already correct
     [REX B]"\x08\xC6"                                ; or r14b, al
     "\xE9"[label-rel-ref good-reg2 4 LE]       ; jmp good-reg2

     [label not-ascii-10]

     ;; If element 2 is a barray of length > 1, try to look up the register by name
     [REX W B]"\x8B\x7C\x24"[imm 8 16]                    ; mov rdi, qword[r12+16]
     [REX W]"\x83\x3F"[imm 8 2]                           ; cmp qword[rdi], 2
     "\x0F\x8C"[label-rel-ref not-reg-name 4 LE]         ; jl not-reg-name
     [REX W]"\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
     "\xFF\xD0"                                          ; call rax
     [REX B]"\x08\xC6"                                   ; or r14b, al
     "\xE9"[label-rel-ref good-reg2 4 LE]                ; jmp good-reg2

     [label not-reg-name]

     ;; If we get here, error
     [REX W]"\xBF"[MODRM-input-error addr 8 LE]        ; mov rdi, MODRM-input-error
     [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0"                                        ; call rax

     [label good-reg2]
     [REX W R]"\x89\xEF"                                          ; mov rdi, r13
     [REX W R]"\x89\xF6"                                          ; mov rsi, r14
     [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int8] ; mov rax, bb_push_byte
     "\xFF\xD0"                                                   ; call rax
     "\xE9"[label-rel-ref mem-operand-done 4 LE]]                 ; jmp mem-operand-done

    [label is-memory-operand]

    [label-scope
     [REX W B]"\x8B\x5C\x24"[imm 8 16] ; mov rbx, qword[r12+16] - rbx = mem operand parray

     ;; Error if our memory operand is not 5 elements long
     [REX W]"\x83\x3B"[imm 8 -6]                           ; cmp qword[rbx], -6
     "\x0F\x84" [label-rel-ref good-mem-operand-len 4 LE] ; je good-mem-operand-len

     [REX W]"\xBF"[MODRM-input-error addr 8 LE]        ; mov rdi, MODRM-input-error
     [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0"                                        ; call rax

     [label good-mem-operand-len]

     ;; TODO error if our memory operand's first element is not m64|m32|m16|m8
     ;;      [maybe make a memory operand validator func]

     ;; Try rip-rel encoding
     [REX W]"\x89\xDF"                                            ; mov rdi, rbx
     [REX W R]"\x89\xEE"                                          ; mov rsi, r13
     [REX W]"\xB8"[RM-try-encode-rip-rel-fn barray-raw-addr 8 LE] ; mov rax, rip-rel-fn
     "\xFF\xD0"                                                   ; call rax
     [REX W]"\x83\xF8"[imm 8 1]                                    ; cmp rax, 1
     "\x0F\x84"[label-rel-ref mem-operand-done 4 LE]              ; je mem-operand-done

     ;; Try mem encoding
     [REX W]"\x89\xDF"                                            ; mov rdi, rbx
     [REX W R]"\x89\xEE"                                          ; mov rsi, r13
     [REX W]"\xB8"[RM-try-encode-mem-fn barray-raw-addr 8 LE]     ; mov rax, mem-fn
     "\xFF\xD0"                                                   ; call rax
     [REX W]"\x83\xF8"[imm 8 1]                                    ; cmp rax, 1
     "\x0F\x84"[label-rel-ref mem-operand-done 4 LE]              ; je mem-operand-done

     ;; Try mem+disp encoding
     [REX W]"\x89\xDF"                                             ; mov rdi, rbx
     [REX W R]"\x89\xEE"                                           ; mov rsi, r13
     [REX W]"\xB8"[RM-try-encode-mem+disp-fn barray-raw-addr 8 LE] ; mov rax, mem+disp-fn
     "\xFF\xD0"                                                    ; call rax
     [REX W]"\x83\xF8"[imm 8 1]                                     ; cmp rax, 1
     "\x0F\x84"[label-rel-ref mem-operand-done 4 LE]               ; je mem-operand-done

     ;; Try mem+sib+disp encoding
     [REX W]"\x89\xDF"                                             ; mov rdi, rbx
     [REX W R]"\x89\xEE"                                           ; mov rsi, r13
     [REX W]"\xB8"[RM-try-encode-mem+sib-fn barray-raw-addr 8 LE]  ; mov rax, mem+sib-fn
     "\xFF\xD0"                                                    ; call rax
     [REX W]"\x83\xF8"[imm 8 1]                                     ; cmp rax, 1
     "\x0F\x84"[label-rel-ref mem-operand-done 4 LE]               ; je mem-operand-done

     ;; Error if we got here, nobody succeeded in encoding this operand
     [REX W]"\xBF"[memop-error addr 8 LE]              ; mov rdi, memop-error
     [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0"]                                       ; call rax

    [label mem-operand-done]

    ;; Now that our r/m operand is encoded, let's 'or' in our first argument
    ;; [2nd element] to specify the register.

    ;; Our first argument - element 2 - can take any of the following forms:
    ;;   * A barray of length > 1: specifying a register by name
    ;;   * A barray of 1 byte: base-10 ascii number representing the register number
    ;;   * A barray of 1 byte: representing the register number [value always < 8]

    [label-scope
     [REX B]"\xB6"[imm 8 0] ; mov r14b, 0  - our output byte

     ;;; If element 2 is a barray of 1 byte and < 8, bitshift+or the byte in
     [REX W B]"\x8B\x7C\x24"[imm 8 8]             ; mov rdi, qword[r12+8]
     [REX W]"\x83\x3F"[imm 8 1]                    ; cmp qword[rdi], 1
     "\x0F\x85" [label-rel-ref not-raw-byte 4 LE] ; jne not-raw-byte
     "\x80\x7F"[imm 8 8][imm 8 8]                   ; cmp byte[rdi+8], 8
     "\x0F\x8D"[label-rel-ref not-raw-byte 4 LE]  ; jge not-raw-byte
     "\x8A\x4F"[imm 8 8]                           ; mov cl, byte[rdi+8]
     "\xC0\xE1"[imm 8 3]                           ; shl cl, 3
     [REX B]"\x08\xCE"                            ; or r14b, cl
     "\xE9"[label-rel-ref good-reg1 4 LE]   ; jmp good-reg1
     [label not-raw-byte]

     ;;; If element 2 is a barray of 1 byte, >= 48 & <= 55, parse the ascii base-10
     ;;; number, then bitshift+or the byte in
     [REX W B]"\x8B\x7C\x24"[imm 8 8]                 ; mov rdi, qword[r12+8]
     [REX W]"\x83\x3F"[imm 8 1]                        ; cmp qword[rdi], 1
     "\x0F\x85"[label-rel-ref not-ascii-10 4 LE]     ; jne not-ascii-10
     "\x80\x7F"[imm 8 8][imm 8 48]                      ; cmp byte[rdi+8], 48
     "\x0F\x8C"[label-rel-ref not-ascii-10 4 LE]     ; jl not-ascii-10
     "\x80\x7F"[imm 8 8][imm 8 55]                      ; cmp byte[rdi+8], 55
     "\x0F\x8F"[label-rel-ref not-ascii-10 4 LE]     ; jg not-ascii-10
     [REX W]"\xB8"[parse-int-fn barray-raw-addr 8 LE] ; mov rax, parse-int-fn
     "\xFF\xD0"                                       ; call rax - rdi already correct
     "\xC0\xE0"[imm 8 3]                               ; shl al, 3
     [REX B]"\x08\xC6"                                ; or r14b, al
     "\xE9"[label-rel-ref good-reg1 4 LE]       ; jmp good-reg1

     [label not-ascii-10]

     ;;; If element 2 is a barray of length > 1, try to look up the register by name
     [REX W B]"\x8B\x7C\x24"[imm 8 8]                 ; mov rdi, qword[r12+8]
     [REX W]"\x83\x3F"[imm 8 2]                        ; cmp qword[rdi], 2
     "\x0F\x8C"[label-rel-ref not-reg-name 4 LE]      ; jl not-reg-name
     [REX W]"\xB8"[reg-name-to-num barray-raw-addr 8 LE] ; mov rax, reg-name-to-num
     "\xFF\xD0"                                       ; call rax
     "\xC0\xE0"[imm 8 3]                               ; shl al, 3
     [REX B]"\x08\xC6"                                ; or r14b, al
     "\xE9"[label-rel-ref good-reg1 4 LE]       ; jmp good-reg1

     [label not-reg-name]

     ;;; If we get here, error
     [REX W]"\xBF"[MODRM-input-error addr 8 LE]        ; mov rdi, MODRM-input-error
     [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
     "\xFF\xD0"                                        ; call rax

     [label good-reg1]

     ;; 'or' our reg1 into our result
     [REX W R]"\x89\xEF"                                           ; mov rdi, r13
     [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]    ; mov rax, bb_get_buf
     "\xFF\xD0"                                                    ; call rax
     "\x48\x03\x45\xD0" ; add rax, qword[rbp-48]
     [REX R]"\x08\x70"[imm 8 8]]                                     ; or byte[rax+8], r14b

    ;; Update our placeholder length to current data length of byte buffer-8
    [REX W R]"\x89\xEF"                                                ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length] ; mov rax, len
    "\xFF\xD0"                                                         ; call rax
    "\x48\x2B\x45\xD0" ; sub rax, qword[rbp-48]
    [REX W]"\x83\xE8"[imm 8 8] ; sub rax, 8

    [REX W R]"\x89\xEF"                                                ; mov rdi, r13
    "\x48\x8B\x75\xD0"; mov rsi, qword[rbp-48]
    [REX W]"\x89\xC2"                                                  ; mov rdx, rax
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-write-int64]     ; mov rax, write
    "\xFF\xD0"                                                         ; call rax

    "\x4C\x89\xEF"                                                    ; mov rdi, r13
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]           ; mov rax, bb_get_buf
    "\xFF\xD0"                                                        ; call rax

    "\x48\x03\x45\xD0" ; add rax, qword[rbp-48]

    "\x48\x83\xC4\x08"                                                ; add rsp, 8
     "\x5B"         ; pop rbx
     [REX B]"\x5F"  ; pop r15
     [REX B]"\x5E"  ; pop r14
     [REX B]"\x5D"  ; pop r13
     [REX B]"\x5C"  ; pop r12
    "\x5D"                                                            ; pop rbp
    "\xC3"]]]      ; ret

 [macro bregnum
  [x86_64-linux
   [bb/barray-cat
    [REX B]"\x54"     ; push r12
    [REX B]"\x55"     ; push r13
    [REX B]"\x56"     ; push r14
    [REX B]"\x57"     ; push r15

    [REX W B]"\x89"[RM rdi r12]   ; mov r12, rdi - input structure*
    [REX W B]"\x89"[RM rsi r13]   ; mov r13, rsi - output byte buffer*

    ;; Create byte buffer for our tail expansion
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-new]              ; mov rax, bb_new
    "\xFF\xD0"                                                        ; call rax
    "\x49\x89\xC7"                                                    ; mov r15, rax

    ;; Create our tail macroexpansion
    "\x4C\x89\xE7"                                                    ; mov rdi, r12
    "\x4C\x89\xFE"                                                    ; mov rsi, r15
    "\xBA\x02\x00\x00\x00"                                            ; mov rdx, 2 - greedy
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand_tail
    "\xFF\xD0"                                                        ; call rax
    "\x49\x89\xC4"                                                    ; mov r12, rax

    ;; Error if our input structure isn't of length 1
    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -2] ; cmp qword[r12], -2
    "\x0F\x84" [label-rel-ref good-size 4 LE] ; je good-size

    [REX W][bb/bsumLE "\xB8" "\x07"][bregnum-bad-use-error addr 8 LE] ; mov rdi, msg
    [REX W]"\xB8"[error-exit-fn barray-raw-addr 8 LE]                    ; mov rax, error-exit-fn
    "\xFF"[RM 2 rax]                                                     ; call rax

    [label good-size]

    ;; Push our length to output buffer [1]
    [REX W R]"\x89"[RM r13 rdi]                                   ; mov rdi, r13
    [REX W]"\xC7\xC6"[imm 32 1]                                   ; mov rsi, 1
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64] ; mov rax, bb_push_int64
    "\xFF"[RM 2 rax]                                              ; call rax

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                       ; mov rdi, qword[r12+8]
    [REX W]"\xB8"[reg-name-to-num barray-raw-addr 8 LE]           ; mov rax, reg-name-to-num
    "\xFF"[RM 2 rax]                                              ; call rax

    ;; Push our output byte to output buffer
    [REX W R]"\x89"[RM r13 rdi]                                       ; mov rdi, r13
    [REX W]"\x89"[RM rax rsi]                                         ; mov rsi, rax
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int8]      ; mov rax, bb_push_int8
    "\xFF"[RM 2 rax]                                                  ; call rax

    ;; Free our tail expansion
    "\x4C\x89\xFF"                                                    ; mov rdi, r15
    "\x48\xB8" [bb/builtin-func-addr/byte-buffer-free]             ; mov rax, bb_free
    "\xFF\xD0"                                                        ; call rax


    "\x4C\x89\xEF"                                                    ; mov rdi, r13
    "\x48\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]           ; mov rax, bb_get_buf
    "\xFF\xD0"                                                        ; call rax
    ; return rax

    [REX B]"\x5F"  ; pop r15
    [REX B]"\x5E"  ; pop r14
    [REX B]"\x5D"  ; pop r13
    [REX B]"\x5C"  ; pop r12
    "\xC3"]]]

 [data reg-type-map [[rax r64] [eax  r32] [ax   r16] [al   r8]
                     [rcx r64] [ecx  r32] [cx   r16] [cl   r8]
                     [rdx r64] [edx  r32] [dx   r16] [dl   r8]
                     [rbx r64] [ebx  r32] [bx   r16] [bl   r8]
                     [rsp r64] [esp  r32] [sp   r16] [spl  s8]
                     [rbp r64] [ebp  r32] [bp   r16] [bpl  s8]
                     [rsi r64] [esi  r32] [si   r16] [sil  s8]
                     [rdi r64] [edi  r32] [di   r16] [dil  s8]

                     ;; Extended registers, use REX prefix to access
                     [r8  re64] [r8d  re32] [r8w  re16] [r8b  re8]
                     [r9  re64] [r9d  re32] [r9w  re16] [r9b  re8]
                     [r10 re64] [r10d re32] [r10w re16] [r10b re8]
                     [r11 re64] [r11d re32] [r11w re16] [r11b re8]
                     [r12 re64] [r12d re32] [r12w re16] [r12b re8]
                     [r13 re64] [r13d re32] [r13w re16] [r13b re8]
                     [r14 re64] [r14d re32] [r14w re16] [r14b re8]
                     [r15 re64] [r15d re32] [r15w re16] [r15b re8]]]

 ;; Inputs a barray [rdi] and returns 1 if it could represent a base-10 ascii integer,
 ;; else 0. Negative numbers are fine.
 [data ascii-base-10-p
  [bb/barray-cat
   [REX W]"\x8B"[RM rsi [m64 rdi 0 1 0]]      ; mov rsi, qword[rdi]
   [REX W]"\x83"[RM 0 rdi][imm 8 8]           ; add rdi, 8 - move past length

   [REX W]"\xC7"[RM 0 rax][imm 32 1]          ; mov rax, 1
   [REX W]"\xC7"[RM 0 rcx][imm 32 0]          ; mov rcx, 0

   [label loop]
   [label-scope
    [REX W]"\x83"[RM 7 rsi][imm 8 0]          ; cmp rsi, 0
    "\x0F\x8E"[label-rel-ref loop-break 4 LE] ; jle loop-break

    [REX]"\x8A"[RM dl [m8 rdi 0 1 0]]         ; mov dl, byte[rdi]
    "\x80"[RM 7 dl][imm 8 45]                 ; cmp dl, '-'
    "\x0F\x84"[label-rel-ref continue 4 LE]   ; je continue

    "\x80"[RM 7 dl][imm 8 48]                 ; cmp dl, 48 / '0'
    [REX W]"\x0F\x4C"[RM rax rcx]             ; cmovl rax, rcx

    "\x80"[RM 7 dl][imm 8 57]                 ; cmp dl, 57 / '9'
    [REX W]"\x0F\x4F"[RM rax rcx]             ; cmovg rax, rcx

    [label continue]
    [REX W]"\x83"[RM 0 rdi][imm 8 1]          ; add rdi, 1
    [REX W]"\xFF"[RM 1 rsi]                   ; dec rsi
    "\xE9"[label-rel-ref loop 4 LE]]          ; jmp loop
   [label loop-break]
   "\xC3"]]


 ;; Returns 1 if the two input parrays [rdi and rsi] share a common barray
 ;; element. Otherwise returns 0.
 [data parrays-intersect-p
  [bb/barray-cat
   [REX B]"\x54"                                                            ; push r12
   [REX B]"\x55"                                                            ; push r13
   [REX B]"\x56"                                                            ; push r14
   [REX B]"\x57"                                                            ; push r15
   "\x53"                                                                   ; push rbx

   [REX W R]"\x8B"[RM r12 rdi]                            ; mov r12, rdi
   [REX W R]"\x8B"[RM r13 rsi]                            ; mov r13, rsi

   [REX W R B]"\x8B"[RM r14 [m64 r12 0 1 0]]                ; mov r14, qword[r12]
   [REX W B]"\xF7"[RM 2 r14]                              ; not r14
   [REX W B]"\x83"[RM 0 r12][imm 8 8]                     ; add r12, 8 - move past len

   [label outer-loop]
   [label-scope
    [REX W B]"\x83"[RM 7 r14][imm 8 0]                    ; cmp r14, 0
    "\x0F\x8E"[label-rel-ref outer-loop-break 4 LE]       ; jle outer-loop-break

    [REX W R B]"\x8B"[RM r15 [m64 r13 0 1 0]]             ; mov r15, qword[r13]
    [REX W B]"\xF7"[RM 2 r15]                             ; not r15
    [REX W B]"\x8B"[RM rbx r13]                           ; mov rbx, r13
    [REX W]"\x83"[RM 0 rbx][imm 8 8]                      ; add rbx, 8 - move past len

    [label inner-loop]
    [label-scope
     [REX W B]"\x83"[RM 7 r15][imm 8 0]                   ; cmp r15, 0
     "\x0F\x8E"[label-rel-ref inner-loop-break 4 LE]      ; jle inner-loop-break

     [REX W B]"\x8B"[RM rdi [m64 r12 0 1 0]]              ; mov rdi, qword[r12]
     [REX W]"\x8B"[RM rsi [m64 rbx 0 1 0]]                ; mov rsi, qword[rbx]
     [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp] ; mov rax, barray-equalp
     "\xFF"[RM 2 rax]                                     ; call rax
     [REX W]"\x83"[RM 7 rax][imm 8 1]                     ; cmp rax, 1
     "\x0F\x84"[label-rel-ref ya 4 LE]                    ; je ya

     [REX W]"\x83"[RM 0 rbx][imm 8 8]                     ; add rbx, 8
     [REX W B]"\xFF"[RM 1 r15]                            ; dec r15
     "\xE9"[label-rel-ref inner-loop 4 LE]]               ; jmp inner-loop
    [label inner-loop-break]

    [REX W B]"\x83"[RM 0 r12][imm 8 8]                    ; add r12, 8
    [REX W B]"\xFF"[RM 1 r14]                             ; dec r14
    "\xE9"[label-rel-ref outer-loop 4 LE]]                ; jmp outer-loop
   [label outer-loop-break]

   [label nah]
   [REX W]"\xC7"[RM 0 rax][imm 32 0]                      ; mov rax, 0
   "\xE9"[label-rel-ref epilogue 4 LE]                   ; jmp epilogue

   [label ya]
   [REX W]"\xC7"[RM 0 rax][imm 32 1]                      ; mov rax, 1
   [label epilogue]
   "\x5B"                                                                   ; pop rbx
   [REX B]"\x5F"                                                            ; pop r15
   [REX B]"\x5E"                                                            ; pop r14
   [REX B]"\x5D"                                                            ; pop r13
   [REX B]"\x5C"                                                            ; pop r12
   "\xC3"]]

 [data imm8-barray  "imm8"]
 [data imm16-barray "imm16"]
 [data imm32-barray "imm32"]
 [data imm64-barray "imm64"]
 [data m64-barray   "m64"]
 [data m32-barray   "m32"]
 [data m16-barray   "m16"]
 [data m8-barray    "m8"]
 [data label-barray "label"]

 [data operand-err "\nERROR: Invalid operand.\n"]

 ;; Inputs an operand [rdi], byte buffer [rsi]. Writes a parray of compatible operand types
 ;; for the operand to the byte buffer.
 ;;
 ;; Returns an absolute pointer to the parray.
 ;;
 ;; TODO the maximum possible length of our output parray is bounded [4 elements max I think].
 ;;      This means it would be more optimal to use a statically sized allocation, not a byte
 ;;      buffer. Maybe even return our result through the stack. This probably isn't too bad
 ;;      as-is though, because in the common case our output will fit into the 'starting'
 ;;      allocation size of the byte buffer. So we're still probably only hitting malloc once.
 [data operand-type-fn
  [bb/barray-cat
    ;; rdi                 -> [r64]
    ;; spl                 -> [s8]
    ;; r15                 -> [re64]
    ;; 5                   -> [imm8 imm16 imm32 imm64]
    ;; 300                 -> [imm16 imm32 imm64]
    ;; foobar              -> [label]
    ;; [m64 rdi 0 1 0]     -> [m64]
    ;; [m32 rsi 0 1 0]     -> [m32]
    ;; [m16 rsi 0 1 0]     -> [m16]
    ;; [m8 rsi 0 1 0]      -> [m8]
    ;; error if nothing matches

    [REX B]"\x54"                                                             ; push r12
    [REX B]"\x55"                                                             ; push r13
    [REX B]"\x56"                                                             ; push r14
    [REX B]"\x57"                                                             ; push r15
    "\x53"                                                                    ; push rbx

    [REX W R]"\x8B"[RM r12 rdi]                                               ; mov r12, rdi - operand structure
    [REX W R]"\x8B"[RM r13 rsi]                                               ; mov r13, rsi - output byte buffer

    [REX W B]"\x8B"[RM rdi r13]                                               ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]        ; mov rax, bb-get-data-len
    "\xFF"[RM 2 rax]                                                          ; call rax
    [REX W]"\x8B"[RM rbx rax]                                                 ; mov rbx, rax - save pointer to update our placeholder

    ;; Write placeholder parray length to byte buffer
    [REX W B]"\x8B"[RM rdi r13]                                               ; mov rdi, r13
    [REX W]"\xC7"[RM 0 rsi][imm 32 -1]                                        ; mov rsi, -1
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]             ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                          ; call rax

    ;; If it's a barray or parray of length 0, just go straight to is-nothing and error
    ;; Means we can assume they have at least a length of 1 in this function moving forwards
    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 0]                            ; cmp qword[r12], 0
    "\x0F\x84"[label-rel-ref is-nothing 4 LE]                                 ; je is-nothing
    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -1]                           ; cmp qword[r12], -1
    "\x0F\x84"[label-rel-ref is-nothing 4 LE]                                 ; je is-nothing

    ;; branch on parray vs barray
    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 0]                            ; cmp qword[r12], 0
    "\x0F\x8C"[label-rel-ref is-parray 4 LE]                                  ; jl is-parray

    [label is-barray]

    ;;   * Scan the reg type map
    ;;   * If it's in there, output accordingly and goto epilogue
    ;;   * Do nothing and fall-through if it's not in there [it's either an invalid operand or not a register]

    [REX W B][bb/bsumLE "\xB8" [bregnum r14]][reg-type-map addr 8 LE]     ; mov r14, reg-type-map

    [REX W R B]"\x8B"[RM r15 [m64 r14 0 1 0]]                                ; mov r15, qword[r14]
    [REX W B]"\xF7"[RM 2 r15]                                                ; not r15
    [REX W B]"\x83"[RM 0 r14][imm 8 8]                                       ; add r14, 8 - move past length

    [label reg-type-map-loop]
    [label-scope
     [REX W B]"\x83"[RM 7 r15][imm 8 0]                                      ; cmp r15, 0
     "\x0F\x8E"[label-rel-ref reg-type-map-loop-break 4 LE]                  ; jle reg-type-map-loop-break

     [REX W B]"\x8B"[RM rdx [m64 r14 0 1 0]]                                 ; mov rdx, qword[r14] - = pair parray
     [REX W]"\x8B"[RM rdi [m64 rdx 0 1 8]]                                   ; mov rdi, qword[rdx+8]
     [REX W B]"\x8B"[RM rsi r12]                                             ; mov rsi, r12
     [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
     "\xFF"[RM 2 rax]                                                        ; call rax
     [REX W]"\x83"[RM 7 rax][imm 8 1]                                        ; cmp rax, 1
     "\x0F\x85"[label-rel-ref continue 4 LE]                                 ; jne continue

     [REX W B]"\x8B"[RM rdi [m64 r14 0 1 0]]                                 ; mov rdx, qword[r14] - = pair parray
     [REX W]"\x8B"[RM rsi [m64 rdx 0 1 16]]                                  ; mov rsi, qword[rdx+16]
     [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
     [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
     "\xFF"[RM 2 rax]                                                        ; call rax
     "\xE9"[label-rel-ref finish 4 LE]                                       ; jmp finish

     [label continue]
     [REX W B]"\x83"[RM 0 r14][imm 8 8]                                      ; add r14, 8
     [REX W B]"\xFF"[RM 1 r15]                                               ; dec r15
     "\xE9"[label-rel-ref reg-type-map-loop 4 LE]]                           ; jmp reg-type-map-loop
    [label reg-type-map-loop-break]

    ;; If it's a base-10 ascii number, that's imm
    [REX W B]"\x8B"[RM rdi r12] ; mov rdi, r12
    [REX W]"\xB8"[ascii-base-10-p barray-raw-addr 8 LE]                      ; mov rax, ascii-base-10-p
    "\xFF"[RM 2 rax]                                                         ; call rax
    [REX W]"\x83"[RM 7 rax][imm 8 0]                                         ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-base-10-imm 4 LE]                           ; je not-base-10-imm

    [REX W B]"\x8B"[RM rdi r12] ; mov rdi, r12
    [REX W]"\xC7"[RM 0 rsi][imm 32 10]                                       ; mov rsi, 10
    [REX W]"\xB8"[parse-int-fn barray-raw-addr 8 LE]                         ; mov rax, parse-int-fn
    "\xFF"[RM 2 rax]                                                         ; call rax

    [REX W]"\x81"[RM 7 rax][imm 32 2147483647]    ; cmp rax, 2147483647
    "\x0F\x8F"[label-rel-ref base-10-imm-64 4 LE] ; jg base-10-imm-64
    [REX W]"\x81"[RM 7 rax][imm 32 -2147483648]   ; cmp rax, -2147483648
    "\x0F\x8C"[label-rel-ref base-10-imm-64 4 LE] ; jl base-10-imm-64
    [REX W]"\x81"[RM 7 rax][imm 32 32767]         ; cmp rax, 32767
    "\x0F\x8F"[label-rel-ref base-10-imm-32 4 LE] ; jg base-10-imm-32
    [REX W]"\x81"[RM 7 rax][imm 32 -32768]        ; cmp rax, -32768
    "\x0F\x8C"[label-rel-ref base-10-imm-32 4 LE] ; jl base-10-imm-32
    [REX W]"\x81"[RM 7 rax][imm 32 127]           ; cmp rax, 127
    "\x0F\x8F"[label-rel-ref base-10-imm-16 4 LE] ; jg base-10-imm-16
    [REX W]"\x81"[RM 7 rax][imm 32 -128]          ; cmp rax, -128
    "\x0F\x8C"[label-rel-ref base-10-imm-16 4 LE] ; jl base-10-imm-16

    [label base-10-imm-8]
    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm8-barray addr 8 LE]       ; mov rsi, imm8-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    [label base-10-imm-16]
    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm16-barray addr 8 LE]      ; mov rsi, imm16-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    [label base-10-imm-32]
    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm32-barray addr 8 LE]      ; mov rsi, imm32-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    [label base-10-imm-64]
    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm64-barray addr 8 LE]      ; mov rsi, imm64-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax

    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish
    [label not-base-10-imm]

    ;; TODO check if it's a base-16 ascii number like 0xFF, that's imm NOTE: imm needs this added
    ;; TODO check if it's a char literal like 'a' NOTE: imm needs this added


    ;; We assume any barray that doesn't match the above situations is a label
    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][label-barray addr 8 LE]      ; mov rsi, label-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax

    "\xE9"[label-rel-ref finish 4 LE]                                    ; jmp finish
    [label is-parray]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m64-barray addr 8 LE]        ; mov rsi, m64-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-m64 4 LE]                                  ; je not-m64

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m64-barray addr 8 LE]        ; mov rsi, m64-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-m64]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m32-barray addr 8 LE]        ; mov rsi, m32-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-m32 4 LE]                                  ; je not-m32

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m32-barray addr 8 LE]        ; mov rsi, m32-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-m32]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m16-barray addr 8 LE]        ; mov rsi, m16-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-m16 4 LE]                                  ; je not-m16

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m16-barray addr 8 LE]        ; mov rsi, m16-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-m16]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m8-barray addr 8 LE]        ; mov rsi, m8-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-m8 4 LE]                                  ; je not-m8

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][m8-barray addr 8 LE]        ; mov rsi, m8-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-m8]


    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][raw-imm-barray addr 8 LE]      ; mov rsi, raw-imm-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-imm64 4 LE]                                  ; je not-imm64

    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -3] ; cmp qword[r12], -3
    "\x0F\x85"[label-rel-ref not-imm64 4 LE]                                 ; jne not-imm64

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]]     ; mov rdi, qword[r12+16]
    [REX W]"\x83"[RM 7 [m64 rdi 0 1 0]][imm 8 8] ; cmp qword[rdi], 8
    "\x0F\x85"[label-rel-ref not-imm64 4 LE]                                 ; jne not-imm64

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm64-barray addr 8 LE]        ; mov rsi, imm64-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-imm64]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][raw-imm-barray addr 8 LE]      ; mov rsi, raw-imm-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-imm32 4 LE]                                  ; je not-imm32

    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -3] ; cmp qword[r12], -3
    "\x0F\x85"[label-rel-ref not-imm32 4 LE]                                 ; jne not-imm32

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]]     ; mov rdi, qword[r12+16]
    [REX W]"\x83"[RM 7 [m64 rdi 0 1 0]][imm 8 4] ; cmp qword[rdi], 4
    "\x0F\x85"[label-rel-ref not-imm32 4 LE]                                 ; jne not-imm32

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm32-barray addr 8 LE]        ; mov rsi, imm32-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-imm32]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][raw-imm-barray addr 8 LE]      ; mov rsi, raw-imm-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-imm16 4 LE]                                  ; je not-imm16

    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -3] ; cmp qword[r12], -3
    "\x0F\x85"[label-rel-ref not-imm16 4 LE]                                 ; jne not-imm16

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]]     ; mov rdi, qword[r12+16]
    [REX W]"\x83"[RM 7 [m64 rdi 0 1 0]][imm 8 2] ; cmp qword[rdi], 4
    "\x0F\x85"[label-rel-ref not-imm16 4 LE]                                 ; jne not-imm16

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm16-barray addr 8 LE]        ; mov rsi, imm16-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-imm16]

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                 ; mov rdi, qword[r12+8]
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][raw-imm-barray addr 8 LE]      ; mov rsi, raw-imm-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                        ; call rax
    [REX W]"\x83"[RM 0 rax][imm 8 0]                                        ; cmp rax, 0
    "\x0F\x84"[label-rel-ref not-imm8 4 LE]                                  ; je not-imm8

    [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -3] ; cmp qword[r12], -3
    "\x0F\x85"[label-rel-ref not-imm8 4 LE]                                 ; jne not-imm8

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]]     ; mov rdi, qword[r12+16]
    [REX W]"\x83"[RM 7 [m64 rdi 0 1 0]][imm 8 1] ; cmp qword[rdi], 4
    "\x0F\x85"[label-rel-ref not-imm8 4 LE]                                 ; jne not-imm8

    [REX W B]"\x8B"[RM rdi r13]                                             ; mov rdi, r13
    [REX W][bb/bsumLE "\xB8" [bregnum rsi]][imm8-barray addr 8 LE]        ; mov rsi, imm8-barray*
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]           ; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                        ; call rax
    "\xE9" [label-rel-ref finish 4 LE]                                      ; jmp finish

    [label not-imm8]

    [label is-nothing]

    ;; Error if we get here
    [REX W][bb/bsumLE "\xB8" [bregnum rdi]][operand-err addr 8 LE]              ; mov rdi, operand-err
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
    "\xFF"[RM 2 rax]                                                               ; call rax

    [label finish]

    ;; Update parray length in byte buffer
    [REX W B]"\x8B"[RM rdi r13] ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]       ; mov rax, bb-get-data-length
    "\xFF"[RM 2 rax]                                                         ; call rax
    "\x48\x29\xD8" ; sub rax, rbx
    [REX W]"\x83"[RM 5 rax][imm 8 8]                                         ; sub rax, 8
    [REX W]"\xC1"[RM 5 rax][imm 8 3]                                         ; shr rax, 3 - / 8
    [REX W]"\xF7"[RM 2 rax]                                                  ; not rax
    ;[REX W]"\x83"[RM 5 rax][imm 8 2]; sub rax, 1

    [REX W B]"\x8B"[RM rdi r13]                                              ; mov rdi, r13
    [REX W]"\x8B"[RM rsi rbx]                                                ; mov rsi, rbx
    [REX W]"\x8B"[RM rdx rax]                                                ; mov rdx, rax
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-write-int64]           ; mov rax, bb-write-int64
    "\xFF"[RM 2 rax]                                                         ; call rax

    [REX W B]"\x8B"[RM rdi r13]                                              ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]               ; mov rax, bb-get-buf
    "\xFF"[RM 2 rax]                                                         ; call rax
    [REX W]"\x03"[RM rax rbx]                                                ; add rax, rbx - return pointer to our data

    [label epilogue]
    "\x5B"                                                                   ; pop rbx
    [REX B]"\x5F"                                                            ; pop r15
    [REX B]"\x5E"                                                            ; pop r14
    [REX B]"\x5D"                                                            ; pop r13
    [REX B]"\x5C"                                                            ; pop r12
    "\xC3"]]

 ;; Returns 1 if the instruction parray [rdi] can be implemented by the impl spec [rsi]
 ;; Impl spec as in an instruction table implementation entry.
 ;; Else Returns 0.
 [data instruction-matches-implementation-p
  [bb/barray-cat
   [REX B]"\x54"                                                             ; push r12
   [REX B]"\x55"                                                             ; push r13
   [REX B]"\x56"                                                             ; push r14
   [REX B]"\x57"                                                             ; push r15
   "\x53"                                                                    ; push rbx

   ;; [[[accepted types for param 0] [accepted types for param 1]] encoding]

   [REX W R]"\x8B"[RM r12 rdi]               ; mov r12, rdi - instruction parray
   [REX W R]"\x8B"[RM r13 rsi]               ; mov r13, rsi - impl spec

   [REX W B]"\x8B"[RM rdi [m64 r12 0 1 0]]   ; mov rdi, qword[r12]
   [REX W]"\xF7"[RM 2 rdi]                   ; not rdi
   [REX W]"\xFF"[RM 1 rdi]                   ; dec rdi - rdi = operand count of instruction

   [REX W R B]"\x8B"[RM r15 [m64 r13 0 1 8]] ; mov r15, qword[r13+8] - r15 = impl spec param list
   [REX W R B]"\x8B"[RM r14 [m64 r15 0 1 0]] ; mov r14, qword[r15]
   [REX W B]"\xF7"[RM 2 r14]                 ; not r14 - r14 = operand count in impl spec

   [REX W B]"\x3B"[RM rdi r14]               ; cmp rdi, r14
   "\x0F\x85"[label-rel-ref nope 4 LE]       ; jne nope

   [REX W B]"\x83"[RM 0 r15][imm 8 8]        ; add r15, 8 - move past len
   [REX W B]"\x83"[RM 0 r12][imm 8 16]       ; add r12, 16 - move past len, first element

   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-new]  ; mox rax, bb-new
   "\xFF"[RM 2 rax]                                                                     ; call rax
   [REX W]"\x8B"[RM rbx rax]                                                            ; mov rbx, rax

   [label param-loop]
   [label-scope
    [REX W B]"\x83"[RM 7 r14][imm 8 0]                                                   ; cmp r14, 0
    "\x0F\x8E"[label-rel-ref param-loop-break 4 LE]                                      ; jle param-loop-break


    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 0]]                                              ; mov rdi, qword[r12]
    [REX W]"\x8B"[RM rsi rbx]                                                            ; mov rsi, rbx
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][operand-type-fn barray-raw-addr 8 LE]     ; mov rax, operand-type-fn
    "\xFF"[RM 2 rax]                                                                     ; call rax

    [REX W]"\x8B"[RM rdi rax]                                                            ; mov rdi, rax
    [REX W B]"\x8B"[RM rsi [m64 r15 0 1 0]]                                              ; mov rsi, qword[r15]
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][parrays-intersect-p barray-raw-addr 8 LE] ; mov rax, parrays-intersect-p
    "\xFF"[RM 2 rax]                                                                     ; call rax

    [REX W]"\x83"[RM 7 rax][imm 8 1]                                                     ; cmp rax, 1
    "\x0F\x85"[label-rel-ref nope 4 LE]                                                  ; jne nope


    [REX W B]"\x83"[RM 0 r12][imm 8 8]                                                   ; add r12, 8 - move past len
    [REX W B]"\x83"[RM 0 r15][imm 8 8]                                                   ; add r15, 8 - move past len
    [REX W B]"\xFF"[RM 1 r14]                                                            ; dec r14
    "\xE9"[label-rel-ref param-loop 4 LE]]                                               ; jmp param-loop
   [label param-loop-break]

   [label yup]
   [REX W]"\xC7"[RM 0 rax][imm 32 1]                                                     ; mov rax, 1
   "\xE9"[label-rel-ref epilogue 4 LE]                                                   ; jmp epilogue
   [label nope]
   [REX W]"\xC7"[RM 0 rax][imm 32 0]                                                     ; mov rax, 0
   [label epilogue]


   "\x50"                                                            ; push rax
   "\x50"                                                            ; push rax
   [REX W]"\x8B"[RM rdi rbx]                                                            ; mov rdi, rbx
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-free] ; mox rax, bb-free
   "\xFF"[RM 2 rax]                                                                     ; call rax
   "\x58"                                                            ; pop rax
   "\x58"                                                            ; pop rax

   "\x5B"                                                                                ; pop rbx
   [REX B]"\x5F"                                                                         ; pop r15
   [REX B]"\x5E"                                                                         ; pop r14
   [REX B]"\x5D"                                                                         ; pop r13
   [REX B]"\x5C"                                                                         ; pop r12
   "\xC3"]]

 [data no-encoding-err "\nERROR: No matching encoding found for instruction.\n"]


 ;; TODO this design is not thread-safe, so if we ever parralellize macroexpansion this will
 ;; need to change. One cool way to fix this would be to have bb/with support thread-local
 ;; storage by saying 'thread-local-data' instead of 'data'

 ;; Used in p-macro to refer to the current instruction during the encoding process.
 ;; Will be updated as a pointer to the instruction before expanding the DSL entry in the instruction table
 [data current-instruction-ptr "\x00\x00\x00\x00\x00\x00\x00\x00"]

 [data p-macro-bad-param-count "\nERROR: Bad parameter count for 'p'.\n"]
 [data p-macro-not-base-10-ascii "\nERROR: Parameter to 'p' macro not a base-10 ascii integer. It must be.\n"]
 [data p-macro-index-too-large "\nERROR: Index passed to 'p' macro too large for instruction being encoded.\n"]

 ;; Macro that will be pushed as 'p' for our instruction encoding DSL for our instruction table
 ;; This will be pushed while we assemble an instruction, and popped afterwards
 ;;
 ;; Obtains the correct parameter values through current-instruction-ptr
 [data p-macro
  [bb/barray-cat
   [REX B]"\x54"                                                             ; push r12
   [REX B]"\x55"                                                             ; push r13
   [REX B]"\x56"                                                             ; push r14
   [REX B]"\x57"                                                             ; push r15
   "\x53"                                                                    ; push rbx

   [REX W R]"\x8B"[RM r12 rdi] ; mov r12, rdi - input structure
   [REX W R]"\x8B"[RM r13 rsi] ; mov r13, rsi - output buffer

   ;; Error if input structure doesn't have at least 2 elements
   [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 -3] ; cmp qword[r12], -3
   "\x0F\x8E"[label-rel-ref good-input-count 4 LE] ; jle good-input-count

   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][p-macro-bad-param-count addr 8 LE]  ; mov rdi, error-msg
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit
   "\xFF"[RM 2 rax]                                                               ; call rax

   [label good-input-count]

   ;; Error if the 2nd element of our input isn't a ascii base 10 int
   [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]]                                         ; mov rdi, qword[r12+16]
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][ascii-base-10-p barray-raw-addr 8 LE] ; mov rax, ascii-base-10-p
   "\xFF"[RM 2 rax]                                                                 ; call rax
   [REX W]"\x83"[RM 7 rax][imm 8 1]                                                 ; cmp rax, 1
   "\x0F\x84"[label-rel-ref is-ascii-base-10 4 LE]                                  ; je is-ascii-base-10

   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][p-macro-not-base-10-ascii addr 8 LE]  ; mov rdi, error-msg
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE]   ; mov rax, error-exit
   "\xFF"[RM 2 rax]                                                                 ; call rax

   [label is-ascii-base-10]

   ;; Parse our 2nd element as a base 10 ascii int
   [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]] ; mov rdi, qword[r12+16]
   [REX W]"\xC7"[RM 0 rsi][imm 32 10] ; mov rsi, 10
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][parse-int-fn barray-raw-addr 8 LE]    ; mov rax, parse-int-fn
   "\xFF"[RM 2 rax]                                                                 ; call rax
   [REX W R]"\x8B"[RM r14 rax]                                                      ; mov r14, rax - r14 = parameter index

   ;; Error if the parsed integer points to beyond our current-instruction's parameter count
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][current-instruction-ptr barray-raw-addr 8 LE] ; mov rsi, current-instruction-ptr-barray-raw-addr
   [REX W]"\x8B"[RM rdi [m64 rsi 0 1 0]] ; mov rdi, qword[rsi]
   [REX W]"\x8B"[RM rsi [m64 rdi 0 1 0]]     ; mov rsi, qword[rdi]
   [REX W]"\xF7"[RM 2 rsi]                   ; not rsi
   [REX W]"\x83"[RM 5 rsi][imm 8 2]          ; sub rsi, 2 - rsi = maximum index
   [REX W R]"\x3B"[RM r14 rsi]               ; cmp r14, rsi
   "\x0F\x8E"[label-rel-ref good-index 4 LE] ; jle good-index

   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][p-macro-index-too-large addr 8 LE] ; mov rdi, error-msg
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE]   ; mov rax, error-exit
   "\xFF"[RM 2 rax]                                                                 ; call rax

   [label good-index]

   ;; Return a pointer to parameter from the current instruction at the user-specified index
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][current-instruction-ptr barray-raw-addr 8 LE] ; mov rsi, current-instruction-ptr-barray-raw-addr
   [REX W]"\x8B"[RM rdi [m64 rsi 0 1 0]] ; mov rdi, qword[rsi]
   [REX W X]"\x8B"[RM rax [m64 rdi r14 8 16]] ; mov rax, qword[rdi+r14*8+16]

   [label epilogue]
   "\x5B"                                                                              ; pop rbx
   [REX B]"\x5F"                                                                       ; pop r15
   [REX B]"\x5E"                                                                       ; pop r14
   [REX B]"\x5D"                                                                       ; pop r13
   [REX B]"\x5C"                                                                       ; pop r12
   "\xC3"]]

 [data p-macro-name "p"]
 [data if-ext-bad-usage "\nERROR: Bad usage of if-ext. Try [if-ext register form]."]

 ;; [if-ext [register] [form]]
 ;; expands to [form] if [register] is an extended register, else expands to nothing
 [macro if-ext
  [x86_64-linux
   [bb/barray-cat
    [REX B]"\x54"                                                             ; push r12
    [REX B]"\x55"                                                             ; push r13
    [REX B]"\x56"                                                             ; push r14
    [REX B]"\x57"                                                             ; push r15
    "\x53"                                                                    ; push rbx

    [REX W R]"\x8B"[RM r12 rdi] ; mov r12, rdi - input structure
    [REX W R]"\x8B"[RM r12 rdi] ; mov r13, rsi - output buffer

    ;; Macroexpand tail of our input - rdi and rsi already correct
    [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                 ; mov rdx, 2
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand
    "\xFF"[RM 2 rax]                                                  ; call rax
    [REX W R]"\x8B"[RM r12 rax]                                       ; mov r12, rax

    ;; Error if input structure not 2 elements
    [REX W B]"\x83"[RM 7 [qword r12 0 1 0]][imm 8 -3]                         ; cmp qword[r12], -3
    "\x0F\x84"[label-rel-ref good-arg-count 4 LE]                             ; je good-arg-count

    [REX W][bb/bsumLE "\xB8" [bregnum rdi]][if-ext-bad-usage addr 8 LE]  ; mov rdi, error-msg
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
    "\xFF"[RM 2 rax]                                                               ; call rax

    [label good-arg-count]

    [REX W B][bb/bsumLE "\xB8" [bregnum r14]][reg-is-ext-list addr 8 LE] ; mov r14, reg-is-ext-list
    [REX W R B]"\x8B"[RM r15 [m64 r14 0 1 0]] ; mov r15, qword[r14]
    [REX W B]"\xF7"[RM 2 r15]                 ; not r15
    [REX W B]"\x83"[RM 0 r14][imm 8 8]        ; add r14, 8 - move past length

    [label loop]
    [label-scope
     [REX W B]"\x83"[RM 7 r15][imm 8 0] ; cmp r15, 0
     "\x0F\x8E"[label-rel-ref loop-break 4 LE] ; jle loop-break

     [REX W B]"\x8B"[RM rdi [m64 r14 0 1 0]]  ; mov rdi, qword[r14]
     [REX W B]"\x8B"[RM rsi [m64 r12 0 1 8]] ; mov rsi, qword[r12+8]
     [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                    ; mov rax, barray-equalp
     "\xFF"[RM 2 rax]                                                               ; call rax
     [REX W]"\x83"[RM 7 rax][imm 8 1]                                                     ; cmp rax, 1
     "\x0F\x84"[label-rel-ref yup 4 LE]                             ; je yup

     [REX W B]"\x83"[RM 0 r14][imm 8 8]        ; add r14, 8 - move past length
     [REX W B]"\xFF"[RM 1 r15]                                               ; dec r15
     "\xE9"[label-rel-ref loop 4 LE]]                                        ; jmp loop
    [label loop-break]

    [label nope]
    [REX W]"\xC7"[RM 0 rax][imm 32 -1] ; mov rax, -1
    "\xE9"[label-rel-ref epilogue 4 LE]                                                   ; jmp epilogue

    [label yup]

    ;; Copy our 3rd element to our output buffer
    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 16]] ; mov rdi, qword[r12+16]
    [REX W B]"\x8B"[RM rsi r13] ; mov rsi, r13
    [REX W]"\xC7"[RM 0 rdx][imm 32 0] ; mov rdx, 0
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand] ; mov rax, expand
    "\xFF"[RM 2 rax]                                                                     ; call rax
    ; return rax

    [label epilogue]
    "\x5B"                                                                              ; pop rbx
    [REX B]"\x5F"                                                                       ; pop r15
    [REX B]"\x5E"                                                                       ; pop r14
    [REX B]"\x5D"                                                                       ; pop r13
    [REX B]"\x5C"                                                                       ; pop r12
    "\xC3"]]]

 [macro memop-base
  [x86_64-linux
   [bb/barray-cat
    [REX B]"\x54"                                                             ; push r12
    [REX B]"\x55"                                                             ; push r13
    [REX B]"\x56"                                                             ; push r14
    [REX B]"\x57"                                                             ; push r15
    "\x53"                                                                    ; push rbx

    [REX W R]"\x8B"[RM r12 rdi] ; mov r12, rdi - input structure
    [REX W R]"\x8B"[RM r12 rdi] ; mov r13, rsi - output buffer

    ;; Macroexpand tail of our input - rdi and rsi already correct
    [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                 ; mov rdx, 2
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand
    "\xFF"[RM 2 rax]                                                  ; call rax
    [REX W R]"\x8B"[RM r12 rax]                                       ; mov r12, rax

    ;; TODO error if r12 not 1 element in size
    ;; TODO error if qword[r12+8] not a parray of 5 elements in size

    [REX W B]"\x8B"[RM rsi [m64 r12 0 1 8]] ; mov rsi, qword[r12+8]
    [REX W]"\x8B"[RM rdi [m64 rsi 0 1 16]] ; mov rdi, qword[rsi+16]
    [REX W B]"\x8B"[RM rsi r13] ; mov rsi, r13
    [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                 ; mov rdx, 2
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand]      ; mov rax, expand
    "\xFF"[RM 2 rax]                                                  ; call rax

    "\x5B"                                                                              ; pop rbx
    [REX B]"\x5F"                                                                       ; pop r15
    [REX B]"\x5E"                                                                       ; pop r14
    [REX B]"\x5D"                                                                       ; pop r13
    [REX B]"\x5C"                                                                       ; pop r12
    "\xC3"]]]

 [macro memop-index
  [x86_64-linux
   [bb/barray-cat
    [REX B]"\x54"                                                             ; push r12
    [REX B]"\x55"                                                             ; push r13
    [REX B]"\x56"                                                             ; push r14
    [REX B]"\x57"                                                             ; push r15
    "\x53"                                                                    ; push rbx

    [REX W R]"\x8B"[RM r12 rdi] ; mov r12, rdi - input structure
    [REX W R]"\x8B"[RM r12 rdi] ; mov r13, rsi - output buffer

    ;; Macroexpand tail of our input - rdi and rsi already correct
    [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                 ; mov rdx, 2
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, expand
    "\xFF"[RM 2 rax]                                                  ; call rax
    [REX W R]"\x8B"[RM r12 rax]                                       ; mov r12, rax

    ;; TODO error if r12 not 1 element in size
    ;; TODO error if qword[r12+8] not a parray of 5 elements in size

    [REX W B]"\x8B"[RM rsi [m64 r12 0 1 8]] ; mov rsi, qword[r12+8]
    [REX W]"\x8B"[RM rdi [m64 rsi 0 1 24]] ; mov rdi, qword[rsi+24]
    [REX W B]"\x8B"[RM rsi r13] ; mov rsi, r13
    [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                 ; mov rdx, 2
    "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
    "\x48\xB8" [bb/builtin-func-addr/structural-macro-expand]      ; mov rax, expand
    "\xFF"[RM 2 rax]                                                  ; call rax

    "\x5B"                                                                              ; pop rbx
    [REX B]"\x5F"                                                                       ; pop r15
    [REX B]"\x5E"                                                                       ; pop r14
    [REX B]"\x5D"                                                                       ; pop r13
    [REX B]"\x5C"                                                                       ; pop r12
    "\xC3"]]]

 [data encode-instruction-fn
  [bb/barray-cat
   "\x55"                                                                              ; push rbp
   "\x48\x89\xE5"                                                                      ; mov rbp, rsp
   [REX B]"\x54"                                                             ; push r12
   [REX B]"\x55"                                                             ; push r13
   [REX B]"\x56"                                                             ; push r14
   [REX B]"\x57"                                                             ; push r15
   "\x53"                                                                    ; push rbx
   "\x48\x83\xEC\x08"                                                ; sub rsp, 8

   ;; [mov [[[r64 re64] [r64  re64]] [REX W] "\x89" [RM rdi rsi]]
   ;;      [[[r64 re64] [m64  me64]] [REX W] "\x89" [RM rdi [m64 rsi 0 1 0]]]
   ;;      [[[r64 re64] [imm32]    ] [REX W] "\xC7" [RM 0 rdi] [imm 32 5]]]

   [REX W R]"\x8B"[RM r12 rdi] ; mov r12, rdi - instruction parray
   [REX W R]"\x8B"[RM r13 rsi] ; mov r13, rsi - matching instruction table entry for this instruction
   [REX W R]"\x8B"[RM r14 rdx] ; mov r14, rdx - output buffer to store accessory data
   [REX W R]"\x8B"[RM r15 rcx] ; mov r15, rcx - output parray to append encoding to

   ;; Iterate over our instruction table entry's implementations
   ;;   * If the implementation matches our instruction, continue to encoding [instruction-matches-implementation-p]

   [REX W B]"\x8B"[RM rbx [m64 r13 0 1 0]] ; mov rbx, qword[r13]
   [REX W]"\xF7"[RM 2 rbx] ; not rbx
   [REX W]"\xFF"[RM 1 rbx] ; dec rbx - rbx = instruction table impl count
   [REX W B]"\x83"[RM 0 r13][imm 8 16] ; add r13, 16 - move past len and instruction name

   [label impl-loop]
   [label-scope
    [REX W]"\x83"[RM 7 rbx][imm 8 0] ; cmp rbx, 0
    "\x0F\x8E"[label-rel-ref impl-loop-break 4 LE] ; jle impl-loop-break

    [REX W B]"\x8B"[RM rdi r12]             ; mov rdi, r12
    [REX W B]"\x8B"[RM rsi [m64 r13 0 1 0]] ; mov rsi, qword[r13]
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][instruction-matches-implementation-p barray-raw-addr 8 LE] ; mov rax, instruction-maches-implementation-p
    "\xFF"[RM 2 rax]                                                                     ; call rax
    [REX W]"\x83"[RM 7 rax][imm 8 1]                                                     ; cmp rax, 1
    "\x0F\x84"[label-rel-ref encode 4 LE]                                                ; je encode

    [REX W B]"\x83"[RM 0 r13][imm 8 8] ; add r13, 8
    [REX W]"\xFF"[RM 1 rbx] ; dec rbx - rbx = instruction table impl count
    "\xE9"[label-rel-ref impl-loop 4 LE]]                                               ; jmp impl-loop
   [label impl-loop-break]

   [label no-impl]
   ;; No matching implementations, error
   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][no-encoding-err addr 8 LE]          ; mov rdi, no-encoding-err
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][error-exit-fn barray-raw-addr 8 LE] ; mov rax, error-exit-fn
   "\xFF"[RM 2 rax]                                                               ; call rax

   "\xE9"[label-rel-ref epilogue 4 LE]                                            ; jmp epilogue
   [label encode]

   ;; Update current-instruction-ptr
   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][current-instruction-ptr barray-raw-addr 8 LE] ; mov rdi, current-instruction-ptr-barray-raw-addr
   [REX W R]"\x89"[RM r12 [m64 rdi 0 1 0]]; mov qword[rdi], r12

   ;; Push p-macro
   [REX W]"\x83"[RM 5 rsp][imm 8 16] ; sub rsp, 16
   [REX W]"\xC7"[RM 0 [m64 rsp 0 1 0]][imm 32 8] ; mov qword[rsp], 8
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][p-macro barray-raw-addr 8 LE] ; mov rsi, p-macro*
   [REX W]"\x89"[RM rsi [m64 rsp 0 1 8]] ; mov qword[rsp+8], rsi
   [REX W]"\x8B"[RM rdx rsp] ; mov rdx, rsp
   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][bb/builtin-addr/macro-stack-structural] ; mov rdi, macro-stack-structural
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][p-macro-name addr 8 LE]                    ; mov rsi, p-macro-name
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/kv-stack-push]     ; mov rax, kv-stack-push
   "\xFF"[RM 2 rax]                                                                      ; call rax
   [REX W]"\x89"[RM rax [m64 rbp 0 1 -48]]; mov qword[rbp-48], rax - = id
   [REX W]"\x83"[RM 0 rsp][imm 8 16] ; add rsp, 16

   ;; Encode instruction [qword[r13]]

   [REX W B]"\x8B"[RM rdi [m64 r13 0 1 0]] ; mov rdi, qword[r13]
   [REX W B]"\x8B"[RM rsi r14] ; mov rsi, r14
   [REX W]"\xC7"[RM 0 rdx][imm 32 2]                                         ; mov rdx, 2 - greedy expand
   "\xB9\x01\x00\x00\x00"                                                    ; mov rcx, 1 - RELATIVE
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/structural-macro-expand-tail] ; mov rax, structural-macro-expand-tail
   "\xFF"[RM 2 rax]                                                               ; call rax
   [REX W R]"\x8B"[RM r13 rax] ; mov r13, rax - r13 = our new parray to push

   [REX W B]"\x8B"[RM rdi r14] ; mov rdi, r14
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-get-buf] ; mov rax, bb-get-buf
   "\xFF"[RM 2 rax]                                                               ; call rax
   [REX W R]"\x03"[RM r13 rax]; add r13 , rax

   ;; Pop p-macro by id
   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][bb/builtin-addr/macro-stack-structural] ; mov rdi, macro-stack-structural
   [REX W]"\x8B"[RM rsi [m64 rbp 0 1 -48]] ; mov rsi, qword[rbp-48]
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/kv-stack-pop-by-id]     ; mov rax, kv-stack-pop-by-id
   "\xFF"[RM 2 rax]                                                                      ; call rax

   ;; Copy return parray's pointers to our output parary, except as buffer-relative
   [REX W B]"\x8B"[RM rbx [m64 r13 0 1 0]] ; mov rbx, qword[r13]
   [REX W]"\xF7"[RM 2 rbx] ; not rbx
   [REX W B]"\x83"[RM 0 r13][imm 8 8] ; add r13, 8 - move past len
   [label ptr-loop]
   [label-scope
    [REX W]"\x83"[RM 7 rbx][imm 8 0] ; cmp rbx, 0
    "\x0F\x8E"[label-rel-ref ptr-loop-break 4 LE] ; jle ptr-loop-break

    [REX W B]"\x8B"[RM rdi r15]             ; mov rdi, r15
    [REX W B]"\x8B"[RM rsi [m64 r13 0 1 0]] ; mov rsi, qword[r13]
    ;[REX W B]"\x2B"[RM rsi r12] ; sub rsi, r12
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-push-int64]; mov rax, bb-push-int64
    "\xFF"[RM 2 rax]                                                               ; call rax

    [REX W B]"\x83"[RM 0 r13][imm 8 8] ; add r13, 8
    [REX W]"\xFF"[RM 1 rbx] ; dec rbx
    "\xE9"[label-rel-ref ptr-loop 4 LE]]                                            ; jmp ptr-loop
   [label ptr-loop-break]

   [label epilogue]
   "\x48\x83\xC4\x08"                                                                 ; add rsp, 8
   "\x5B"                                                                              ; pop rbx
   [REX B]"\x5F"                                                                       ; pop r15
   [REX B]"\x5E"                                                                       ; pop r14
   [REX B]"\x5D"                                                                       ; pop r13
   [REX B]"\x5C"                                                                       ; pop r12
   "\x5D"                                                                              ; pop rbp
   "\xC3"]]

 ;; TODO separate functions with label scopes
 [data asm-rel-fn
  [bb/barray-cat
   ;; ------------------
   ;; Top-level asm function, returns buffer-relative pointer to output parray (starting with barray-cat or label-scope)
   [label asm-rel-fn]
   "\x55"                                                                              ; push rbp
   "\x48\x89\xE5"                                                                      ; mov rbp, rsp
   [REX B]"\x54"                                                                       ; push r12
   [REX B]"\x55"                                                                       ; push r13
   [REX B]"\x56"                                                                       ; push r14
   [REX B]"\x57"                                                                       ; push r15
   "\x53"                                                                              ; push rbx
   "\x48\x83\xEC\x18"                                                                  ; sub rsp, 24

   ;; Save our inputs into callee-preserve registers
   [REX W B]"\x89"[RM rdi r12]                                                         ; mov r12, rdi - input structure*
   [REX W B]"\x89"[RM rsi r13]                                                         ; mov r13, rsi - output byte buffer*
   [REX W R]"\x8B"[RM r15 rdx]                                                         ; mov r15, rdx - say barray-cat (0) or label-scope (1)

   ;; Start a new byte buffer for our parray output
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-new] ; mov rax, bb_new
   "\xFF"[RM 2 rax]                                                                    ; call rax
   [REX W B]"\x89"[RM rax r14]                                                         ; mov r14, rax

   ;; Write a placeholder parray length to our parray output byte buffer
   [REX W R]"\x89"[RM r14 rdi]                                                         ; mov rdi, r14
   [REX W]"\xC7"[RM 0 rsi][imm 32 -1]                                                  ; mov rsi, -1
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]                       ; mov rax, bb_push_int64
   "\xFF"[RM 2 rax]                                                                    ; call rax

   ;; Write a pointer to "bb/barray-cat" or "label-scope" as the first element
   ;; of our parray output. We need to copy it into our output buffer because we're
   ;; working with relative pointers in this macro.
   [REX W][bb/bsumLE "\xB8" [bregnum rdi]][label-scope-name addr 8 LE] ; mov rdi, label-scope-name
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][barray-cat-macro-name addr 8 LE] ; mov rsi, barray-cat-macro-name
   [REX W B]"\x83"[RM 7 r15][imm 8 0]; cmp r15, 0
   [REX W]"\x0F\x44"[RM rdi rsi]

   [REX W B]"\x8B"[RM rsi r13] ; mov rsi, r13
   [REX W]"\xC7"[RM 0 rdx][imm 32 0] ; mov rdx, 0
   [REX W]"\xC7"[RM 0 rcx][imm 32 1] ; mov rcx, 1
   [REX W]"\xB8"[bb/builtin-func-addr/structural-macro-expand]               ; mov rax, structural-macro-expand
   "\xFF"[RM 2 rax]                                                          ; call rax

   [REX W R]"\x89"[RM r14 rdi]                                                         ; mov rdi, r14
   [REX W]"\x8B"[RM rsi rax]                                                           ; mov rsi, rax
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]                          ; mov rax, bb_push_int64
   "\xFF"[RM 2 rax]                                                                    ; call rax

   ;; Create input tail macroexpand byte buffer
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][bb/builtin-func-addr/byte-buffer-new] ; mov rax, bb_new
   "\xFF"[RM 2 rax]                                                                    ; call rax
   [REX W]"\x89"[RM rax rbx]                                                           ; mov rbx, rax

   ;; Macroexpand tail of our input into input tail buffer
   "\x4C\x89\xE7"                                                                      ; mov rdi, r12
   "\x48\x89\xDE"                                                                      ; mov rsi, rbx
   "\xBA\x02\x00\x00\x00"                                                              ; mov rdx, 2 - greedy
   "\xB9\x00\x00\x00\x00"                                            ; mov rcx, 0
   "\x48\xB8"[bb/builtin-func-addr/structural-macro-expand-tail]                    ; mov rax, expand_tail
   "\xFF\xD0"                                                                          ; call rax
   [REX W]"\x89"[RM rax [m64 rbp 0 1 -48]]                                             ; mov qword[rbp-48], rax

   ;; Assemble our tail, producing a new barray-cat parray
   [REX W]"\x8B"[RM rdi rax] ; mov rdi, rax
   [REX W B]"\x8B"[RM rsi r13]                                                        ; mov rsi, r13 - output buffer
   [REX W B]"\x8B"[RM rdx r14]                                                        ; mov rdx, r14 - output parray
   "\xE8"[label-rel-ref assemble-fn 4 LE]          ; call assemble-fn

   ;; Update parray output buffer length [currently placeholder]
   [REX W R]"\x89"[RM r14 rdi]                                                         ; mov rdi, r14
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]                  ; mov rax, bb-data-len
   "\xFF"[RM 2 rax]                                                                    ; call rax
   [REX W]"\x83"[RM 5 rax][imm 8 8]                                                    ; sub rax, 8 - don't include length itself
   [REX W]"\xC1"[RM 5 rax][imm 8 3]                                                    ; shr rax, 3 - /8
   [REX W]"\xF7"[RM 2 rax]                                                             ; not rax

   [REX W R]"\x89"[RM r14 rdi]                                                         ; mov rdi, r14
   [REX W]"\xC7"[RM 0 rsi][imm 32 0]                                                   ; mov rsi, 0
   [REX W]"\x89"[RM rax rdx]                                                           ; mov rdx, rax
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-write-int64]                      ; mov rax, bb-write-int64
   "\xFF"[RM 2 rax]                                                                    ; call rax

   ;; Grab our current data len in output buffer to use as our return relpointer
   [REX W R]"\x89"[RM r13 rdi]                                                         ; mov rdi, r13
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]                  ; mov rax, bb-get-data-len
   "\xFF"[RM 2 rax]                                                                    ; call rax
   [REX W B]"\x89"[RM rax r15]                                                         ; mov r15, rax

   ;; Output our parray output byte buffer to our output byte buffer
   [REX W R]"\x89"[RM r13 rdi]                                                         ; mov rdi, r13
   [REX W R]"\x89"[RM r14 rsi]                                                         ; mov rsi, r14
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-byte-buffer]                 ; mov rax, bb-push-bb
   "\xFF"[RM 2 rax]                                                                    ; call rax

   ;; Free our parray output byte buffer
   [REX W R]"\x89"[RM r14 rdi] ; mov rdi, r14
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-free]                             ; mov rax, bb-free
   "\xFF"[RM 2 rax]                                                                    ; call rax

   ;; Free our tail macroexpand buffer
   [REX W]"\x89"[RM rbx rdi]                                                           ; mov rdi, rbx
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-free]                             ; mov rax, bb-free
   "\xFF"[RM 2 rax] ; call rax

   [REX W B]"\x8B"[RM rax r15]; mov rax, r15

   "\x48\x83\xC4\x18"                                                                  ; add rsp, 24
   "\x5B"                                                                              ; pop rbx
   [REX B]"\x5F"                                                                       ; pop r15
   [REX B]"\x5E"                                                                       ; pop r14
   [REX B]"\x5D"                                                                       ; pop r13
   [REX B]"\x5C"                                                                       ; pop r12
   "\x5D"                                                                              ; pop rbp
   "\xC3"

   ;; ----------------------

   [label assemble-fn]
   [REX B]"\x54"                                                                       ; push r12
   [REX B]"\x55"                                                                       ; push r13
   [REX B]"\x56"                                                                       ; push r14
   [REX B]"\x57"                                                                       ; push r15
   "\x53"                                                                              ; push rbx

   [REX W B]"\x89"[RM rdi r12]                                                         ; mov r12, rdi - input - parray* of instructions and stuff
   [REX W B]"\x89"[RM rsi r13]                                                         ; mov r13, rsi - output byte buffer*
   [REX W B]"\x89"[RM rdx r14]                                                         ; mov r14, rdx - output parray*

   [REX W R B]"\x8B"[RM r15 [m64 r12 0 1 0]]                                           ; mov r15, qword[r12]
   [REX W B]"\xF7"[RM 2 r15]                                                           ; not r15

   [REX W B]"\x83"[RM 0 r12][imm 8 8]                                                  ; add r12, 8 - move past length

   [label element-loop]
   [label-scope
    [REX W B]"\x83"[RM 7 r15][imm 8 0]                                                 ; cmp r15, 0
    "\x0F\x84"[label-rel-ref element-loop-break 4 LE]                                  ; je element-loop-break

    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 0]]                                            ; mov rdi, qword[r12]
    [REX W B]"\x8B"[RM rsi r13]                                                        ; mov rsi, r13 - output buffer
    [REX W B]"\x8B"[RM rdx r14]                                                        ; mov rdx, r14 - output parray
    "\xE8"[label-rel-ref assemble-element-fn 4 LE]                                     ; call assemble-element-fn

    [REX W B]"\x83"[RM 0 r12][imm 8 8]                                                 ; add r12, 8
    [REX W B]"\xFF"[RM 1 r15]                                                          ; dec r15
    "\xE9"[label-rel-ref element-loop 4 LE]]                                           ; jmp element-loop
   [label element-loop-break]

   "\x5B"                                                                              ; pop rbx
   [REX B]"\x5F"                                                                       ; pop r15
   [REX B]"\x5E"                                                                       ; pop r14
   [REX B]"\x5D"                                                                       ; pop r13
   [REX B]"\x5C"                                                                       ; pop r12
   "\xC3"

   ;; --------------

   [label assemble-element-fn]
   [REX B]"\x54"                                                             ; push r12
   [REX B]"\x55"                                                             ; push r13
   [REX B]"\x56"                                                             ; push r14
   [REX B]"\x57"                                                             ; push r15
   "\x53"                                                                    ; push rbx

   [REX W R]"\x8B"[RM r12 rdi]                                               ; mov r12, rdi - r12 = the element to assemble
   [REX W R]"\x8B"[RM r13 rsi]                                               ; mov r13, rsi - output buffer
   [REX W R]"\x8B"[RM r14 rdx]                                               ; mov r14, rdx - output parray

   ;; NOTE: write buffer-relative pointers - not abs - in the output parray.

   ;; If the element is a barray:
   ;; * write the barray [not a pointer] to our output byte buffer
   ;; * write a pointer to the barray to our parray output buffer

   [REX W B]"\x83"[RM 7 [m64 r12 0 1 0]][imm 8 0]                            ; cmp qword[r12], 0
   "\x0F\x8C"[label-rel-ref not-barray 4 LE]                                 ; jl not-barray

   [REX W R]"\x89"[RM r13 rdi]                                               ; mov rdi, r13
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-data-length]        ; mov rax, bb-get-data-len
   "\xFF"[RM 2 rax]                                                          ; call rax

   [REX W R]"\x89"[RM r14 rdi]                                               ; mov rdi, r14
   [REX W]"\x89"[RM rax rsi]                                                 ; mov rsi, rax
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]             ; mov rax, bb-push-int64
   "\xFF"[RM 2 rax]                                                          ; call rax

   [REX W R]"\x89"[RM r13 rdi]                                               ; mov rdi, r13
   [REX W R]"\x89"[RM r12 rsi]                                               ; mov rsi, r12
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-barray]            ; mov rax, bb-push-barray
   "\xFF"[RM 2 rax]                                                          ; call rax

   "\xE9"[label-rel-ref epilogue 4 LE]                                       ; jmp epilogue
   [label not-barray]

   ;; It's a parray, scan instruction table to see if it's an instruction

   ;; If the parray is zero-length, it's not an instruction
   [REX W B]"\x8B"[RM rdi [m64 r12 0 1 0]] ; mov rdi, qword[r12]
   [REX W]"\xF7"[RM 2 rdi]                 ; not rdi
   [REX W]"\x83"[RM 7 rdi][imm 8 -1]       ; cmp rdi, -1
   "\x0F\x84"[label-rel-ref not-instruction 4 LE]                            ; je not-instruction

   [REX W][bb/bsumLE "\xB8" [bregnum rbx]][instruction-table addr 8 LE]   ; mov rbx, instruction-table
   [REX W R]"\x8B"[RM r15 [m64 rbx 0 1 0]]                                   ; mov r15, qword[rbx]
   [REX W B]"\xF7"[RM 2 r15]                                                 ; not r15 - r15 = table entry count

   [REX W]"\x83"[RM 0 rbx][imm 8 8]                                          ; add rbx, 8 - move past length

   [label table-loop]
   [label-scope
    [REX W B]"\x83"[RM 7 r15][imm 8 0]                                       ; cmp r15, 0
    "\x0F\x8E"[label-rel-ref table-loop-break 4 LE]                          ; jle table-loop-break

    [REX W]"\x8B"[RM rdi [m64 rbx 0 1 0]]                                    ; mov rdi, qword[rbx]   - rdi = entry parray
    [REX W]"\x8B"[RM rsi [m64 rdi 0 1 8]]                                    ; mov rsi, qword[rdi+8] - rsi = name of entry barray
    [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]]                                  ; mov rdi, qword[r12+8] - rdi = name of user's instruction
    [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                     ; mov rax, barray-equalp
    "\xFF"[RM 2 rax]                                                         ; call rax
    [REX W]"\x83"[RM 7 rax][imm 8 1]                                         ; cmp rax, 1
    "\x0F\x84"[label-rel-ref is-instruction 4 LE]                            ; je is-instruction

    [REX W]"\x83"[RM 0 rbx][imm 8 8]                                         ; add rbx, 8
    [REX W B]"\xFF"[RM 1 r15]                                                ; dec r15
    "\xE9"[label-rel-ref table-loop 4 LE]]                                   ; jmp table-loop
   [label table-loop-break]

   [label not-instruction]
   ;; It's not an instruction name. If it's a label-scope, we need to recurse.
   [REX W B]"\x8B"[RM rdi [m64 r12 0 1 8]] ; mov rdi, qword[r12+8]
   [REX W][bb/bsumLE "\xB8" [bregnum rsi]][label-scope-name addr 8 LE]    ; mov rsi, label-scope-name
   [REX W]"\xB8"[bb/builtin-func-addr/barray-equalp]                     ; mov rax, barray-equalp
   "\xFF"[RM 2 rax]                                                         ; call rax
   [REX W]"\x83"[RM 7 rax][imm 8 1]                                         ; cmp rax, 1
   "\x0F\x85"[label-rel-ref not-scope 4 LE]                                                  ; jne not-scope

   ;; Recurse w/ relative version with same output buffer, tail of label-scope as input
   [REX W B]"\x8B"[RM rdi r12] ; mov rdi, r12
   [REX W B]"\x8B"[RM rsi r13] ; mov rsi, r13
   [REX W]"\xC7"[RM 0 rdx][imm 32 1] ; mov rdx, 1 - we want label scope
   "\xE8"[label-rel-ref asm-rel-fn 4 LE] ; call asm-rel-fn

   ;; Copy new output parray to output byte buffer
   [REX W B]"\x8B"[RM rdi r14]                                               ; mov rdi, r14
   [REX W]"\x8B"[RM rsi rax]                                                 ; mov rsi, rax
   [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]                ; mov rax, byte-buffer-push-int64
   "\xFF"[RM 2 rax]                                                          ; call rax
   "\xE9"[label-rel-ref epilogue 4 LE]                                      ; jmp epilogue
   [label not-scope]

   [label-scope
    ;; It's not an instruction name or label-scope, just forward this parray to barray-cat

    ;; Recursive copy this input using macroexpand into our output buffer
    [REX W B]"\x8B"[RM rdi r12]                                               ; mov rdi, r12
    [REX W B]"\x8B"[RM rsi r13]                                               ; mov rsi, r13
    [REX W]"\xC7"[RM 0 rdx][imm 32 0]                                         ; mov rdx, 0
    "\xB9\x01\x00\x00\x00"                                                    ; mov rcx, 1 - RELATIVE
    [REX W]"\xB8"[bb/builtin-func-addr/structural-macro-expand]               ; mov rax, structural-macro-expand
    "\xFF"[RM 2 rax]                                                          ; call rax
    [REX W]"\x8B"[RM rbx rax]                                                 ; mov rbx, rax

    ;; Write a buffer-relative pointer to the thing we should expanded to our parray
    [REX W B]"\x8B"[RM rdi r14]                                               ; mov rdi, r14
    [REX W]"\x8B"[RM rsi rbx]                                                 ; mov rsi, rbx
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-push-int64]                ; mov rax, byte-buffer-push-int64
    "\xFF"[RM 2 rax]                                                          ; call rax

    "\xE9"[label-rel-ref epilogue 4 LE]]                                      ; jmp epilogue

   [label is-instruction]
   ;; It's an instruction name

   [REX W B]"\x8B"[RM rdi r12]; mov rdi, r12
   [REX W]"\x8B"[RM rsi [m64 rbx 0 1 0]]; mov rsi, qword[rbx]
   [REX W B]"\x8B"[RM rdx r13]; mov rdx, r13
   [REX W B]"\x8B"[RM rcx r14]; mov rcx, r14
   [REX W][bb/bsumLE "\xB8" [bregnum rax]][encode-instruction-fn barray-raw-addr 8 LE] ; mov rax, encode-instruction-fn
   "\xFF"[RM 2 rax]                                                          ; call rax

   "\xE9"[label-rel-ref epilogue 4 LE]                                       ; jmp epilogue

   [label epilogue]
   "\x5B"                                                                              ; pop rbx
   [REX B]"\x5F"                                                                       ; pop r15
   [REX B]"\x5E"                                                                       ; pop r14
   [REX B]"\x5D"                                                                       ; pop r13
   [REX B]"\x5C"                                                                       ; pop r12
   "\xC3"

   ]]

 [macro asm/x86_64
  [x86_64-linux
   [bb/barray-cat
    "\x55"                                                                              ; push rbp
    "\x48\x89\xE5"                                                                      ; mov rbp, rsp
    [REX B]"\x54"                                                                       ; push r12
    [REX B]"\x55"                                                                       ; push r13
    [REX B]"\x56"                                                                       ; push r14
    [REX B]"\x57"                                                                       ; push r15
    "\x53"                                                                              ; push rbx
    "\x48\x83\xEC\x18"                                                                  ; sub rsp, 24


   [REX W B]"\x89"[RM rdi r12]                                                         ; mov r12, rdi - input structure*
   [REX W B]"\x89"[RM rsi r13]                                                         ; mov r13, rsi - output byte buffer*

    [REX W]"\xC7"[RM 0 rdx][imm 32 0] ; mov rdx, 1
    [REX W]"\xB8"[asm-rel-fn barray-raw-addr 8 LE]                                 ; mov rax, asm-rel-fn
    "\xFF"[RM 2 rax]                                                                 ; call rax
    [REX W R]"\x8B"[RM r15 rax] ; mov r15, rax

    ;; Convert the buffer-relative pointers in our output parray to absolute pointers.
    ;;   * Skip the first element - bb/barray-cat - because that's already absolute
    ;;   * Needed because our output buffer is still growing when we write the parray pointers
    ;;     * Growing == invalidating absolute pointers for a byte buffer

    [REX W B]"\x8B"[RM rdi r13]                                                      ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]                          ; mov rax, bb-get-buf
    "\xFF"[RM 2 rax]                                                                 ; call rax

    [REX W B]"\x8B"[RM rdi r15]                                                        ; mov rdi, r15
    [REX W]"\x03"[RM rdi rax]                                                          ; add rdi, rax - rdi = absolute address to parray
    [REX W B]"\x8B"[RM rsi r13]                                                        ; mov rsi, r13 - output buffer
    [REX W]"\xB8"[bb/builtin-func-addr/rel-to-abs]                                     ; mov rax, rel-to-abs
    "\xFF"[RM 2 rax]                                                                   ; call rax

    ;; Return pointer to our parray output in the output byte buffer
    [REX W R]"\x89"[RM r13 rdi]                                                         ; mov rdi, r13
    [REX W]"\xB8"[bb/builtin-func-addr/byte-buffer-get-buf]                             ; mov rax, bb_get_buf
    "\xFF"[RM 2 rax]                                                                    ; call rax
    [REX W B]"\x03"[RM rax r15]                                                         ; add rax, r15

    "\x48\x83\xC4\x18"                                                                  ; add rsp, 24
    "\x5B"                                                                              ; pop rbx
    [REX B]"\x5F"                                                                       ; pop r15
    [REX B]"\x5E"                                                                       ; pop r14
    [REX B]"\x5D"                                                                       ; pop r13
    [REX B]"\x5C"                                                                       ; pop r12
    "\x5D"                                                                              ; pop rbp
    "\xC3"]]]

 [macro operand-type
  [x86_64-linux
   [asm/x86_64
    [push r12]
    [mov r12 rdi]
    [mov rdi [m64 r12 0 1 16]]
    [REX W][bb/bsumLE "\xB8" [bregnum rax]][operand-type-fn barray-raw-addr 8 LE]
    [call-abs rax]

    [pop r12]
    [ret]]]]]
